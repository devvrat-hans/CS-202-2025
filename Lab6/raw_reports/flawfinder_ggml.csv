File,Line,Column,DefaultLevel,Level,Category,Name,Warning,Suggestion,Note,CWEs,Context,Fingerprint,ToolVersion,RuleId,HelpUri
./ggml/src/ggml-backend-reg.cpp,454,23,5,5,race,readlink,"This accepts filename arguments; if an attacker can move those files or change the link content, a race condition results.  Also, it does not terminate with ASCII NUL. (CWE-362, CWE-20).",Reconsider approach.,,"CWE-362, CWE-20","        ssize_t len = readlink(""/proc/self/exe"", path.data(), path.size());",7a80908e9972915b0769a1d2f920543e4634c891566190fdf3ba7c9ad68f6bef,2.0.19,FF1035,https://cwe.mitre.org/data/definitions/362.html
./ggml/src/ggml-backend-reg.cpp,456,23,5,5,race,readlink,"This accepts filename arguments; if an attacker can move those files or change the link content, a race condition results.  Also, it does not terminate with ASCII NUL. (CWE-362, CWE-20).",Reconsider approach.,,"CWE-362, CWE-20","        ssize_t len = readlink(""/proc/curproc/file"", path.data(), path.size());",933dbd3b96835a6ad359bc9f8a67b5d37f893a4f53fb1c879a906509fef680c6,2.0.19,FF1035,https://cwe.mitre.org/data/definitions/362.html
./ggml/include/ggml.h,204,62,4,4,format,printf,"If format strings can be influenced by an attacker, they can be exploited (CWE-134).",Use a constant for the format specification.,,CWE-134,"#    define GGML_ATTRIBUTE_FORMAT(...) __attribute__((format(printf, __VA_ARGS__)))",61905f53cef0f8f7a8d810c642fc9785646b9ce55a9cfb7ff321a31883b28018,2.0.19,FF1016,https://cwe.mitre.org/data/definitions/134.html
./ggml/src/ggml-backend.cpp,768,30,4,4,format,sprintf,Potential format string problem (CWE-134).,Make format string constant.,,CWE-134,"#define SET_CAUSE(node, ...) sprintf(causes[hash_id(node)], __VA_ARGS__)",ced398fbcadc414266f1bc9319c69b53bc44ed61aa164dc9f0baef8d24fc67fa,2.0.19,FF1015,https://cwe.mitre.org/data/definitions/134.html
./ggml/src/ggml-opt.cpp,280,5,4,4,buffer,strcpy,Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).,"Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused).",,CWE-120,"    strcpy(new_tensor->name, tensor->name);",aad3bd78a728ef18c3018b4f01b7798a9b18defd0aa9923f6c80d065ea81a417,2.0.19,FF1001,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-rpc/ggml-rpc.cpp,1100,9,4,4,format,snprintf,"If format strings can be influenced by an attacker, they can be exploited, and note that sprintf variations do not always \0-terminate (CWE-134).",Use a constant for the format specification.,,CWE-134,"        snprintf(hash_str, sizeof(hash_str), ""%016"" PRIx64, hash);",49b6b0c648f4ab21532401e719ed6519549890db2822a71227c63fda7efb8c4d,2.0.19,FF1019,https://cwe.mitre.org/data/definitions/134.html
./ggml/src/ggml-rpc/ggml-rpc.cpp,1116,5,4,4,format,snprintf,"If format strings can be influenced by an attacker, they can be exploited, and note that sprintf variations do not always \0-terminate (CWE-134).",Use a constant for the format specification.,,CWE-134,"    snprintf(hash_str, sizeof(hash_str), ""%016"" PRIx64, hash);",49b6b0c648f4ab21532401e719ed6519549890db2822a71227c63fda7efb8c4d,2.0.19,FF1019,https://cwe.mitre.org/data/definitions/134.html
./ggml/src/ggml-sycl/common.hpp,61,13,4,4,format,fprintf,"If format strings can be influenced by an attacker, they can be exploited (CWE-134).",Use a constant for the format specification.,,CWE-134,"            fprintf(stderr, __VA_ARGS__); \",bbe9670c6812e9424a68276674746d07a6a2408ab123569c58c91fb002dc2484,2.0.19,FF1017,https://cwe.mitre.org/data/definitions/134.html
./ggml/src/ggml-sycl/common.hpp,482,45,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,    return acc.template get_multi_ptr<sycl::access::decorated::no>().get();,3d504f9b4af49878d10431151148c18638c96d1d9a0881a9baea03aa3c4f2a45,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/dequantize.hpp,404,28,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,    item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/dequantize.hpp,443,28,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,    item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/dpct/helper.hpp,1300,36,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,            static constexpr sycl::access::target target =,dd5d197d9735ac1bcd08988ae03eaa064393d8dfb999046fb873f402e960fb0d,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/dpct/helper.hpp,1301,23,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,                sycl::access::target::device;,dfe4214a874c5114341e9b2af9ef2c1266ff45dc15882763ac15516e8b01a556,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/dpct/helper.hpp,2905,19,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,            sycl::access::address_space addressSpace =,f858786ea75b21e3630bc69a29ccffc88a4c707ce8c48795951692d9b77913ef,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/dpct/helper.hpp,2906,23,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,"                sycl::access::address_space::global_space,",b043a28aed315c9a3efc83053cb2c9e0c1e8e9424ec0e90339715785dba107b6,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/dpct/helper.hpp,2915,21,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,    template <sycl::access::address_space addressSpace =,150d76488675afbbce9f467a258231c0551170855d5da58fbf4c6c6ff05b0bca,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/dpct/helper.hpp,2916,23,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,"                sycl::access::address_space::global_space,",b043a28aed315c9a3efc83053cb2c9e0c1e8e9424ec0e90339715785dba107b6,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/dpct/helper.hpp,2926,33,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,"    template <typename T, sycl::access::address_space addressSpace =",33ce269057387d95b32a08f470b009dd3492a0bf1e0a77f7faf7f8a6d882efd9,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/dpct/helper.hpp,2927,35,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,                            sycl::access::address_space::global_space>,80d766f7309be1817d227e92fec4869bd7e42ebc672e84bb133d4123e9bbbd9e,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/dpct/helper.hpp,2947,21,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,    template <sycl::access::address_space addressSpace =,150d76488675afbbce9f467a258231c0551170855d5da58fbf4c6c6ff05b0bca,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/dpct/helper.hpp,2948,23,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,"                sycl::access::address_space::global_space,",b043a28aed315c9a3efc83053cb2c9e0c1e8e9424ec0e90339715785dba107b6,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,1529,28,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,    item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,1557,36,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,            item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,1758,64,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,                        dpct_local_acc_ct1.get_multi_ptr<sycl::access::decorated::no>(),b3fc801b7d674230028701ac062c276b677086ee9783242c89df2bec0666136a,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,1772,64,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,                        dpct_local_acc_ct1.get_multi_ptr<sycl::access::decorated::no>(),b3fc801b7d674230028701ac062c276b677086ee9783242c89df2bec0666136a,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,1812,40,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,                item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,1823,44,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,                    item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,3268,42,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,            dpct::atomic_fetch_add<sycl::access::address_space::generic_space>(,2a85b6c8d553094c736c19ed668dab803df73e007b28af0c052a877cb25d6a44,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/gla.cpp,37,36,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,                item.barrier(sycl::access::fence_space::local_space);  //sync threads,6769d0beac60857859ae2decf5865cfeb86551a9f85ed7573fb39558d9e14ae9,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/gla.cpp,41,36,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,                item.barrier(sycl::access::fence_space::local_space);  //sync threads,6769d0beac60857859ae2decf5865cfeb86551a9f85ed7573fb39558d9e14ae9,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/norm.cpp,42,32,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,        item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/norm.cpp,187,32,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,        item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/norm.cpp,232,32,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,        item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/softmax.cpp,60,32,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,        item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/softmax.cpp,65,32,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,        item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/softmax.cpp,89,32,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,        item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/softmax.cpp,96,32,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,        item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/softmax.cpp,101,32,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,        item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/wkv.cpp,39,28,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,    item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/wkv.cpp,43,28,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,    item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/wkv.cpp,50,32,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,        item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/wkv.cpp,57,32,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,        item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/wkv.cpp,132,32,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,        item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/wkv.cpp,140,32,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,        item_ct1.barrier(sycl::access::fence_space::local_space);,64f0c855e93835df898d1fdaf0365e9016b9092a8e827334c2fc5622d1f71707,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/wkv.cpp,218,78,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,"                        item_ct1, (float*)shared_mem_acc.get_multi_ptr<sycl::access::decorated::no>().get()",63f1e29ba5a6cfd9dca80b2902e493d05d7e66c416f838ea9cdb1fad48074471,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/wkv.cpp,231,78,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,"                        item_ct1, (float*)shared_mem_acc.get_multi_ptr<sycl::access::decorated::no>().get()",63f1e29ba5a6cfd9dca80b2902e493d05d7e66c416f838ea9cdb1fad48074471,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/wkv.cpp,275,78,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,"                        item_ct1, (float*)shared_mem_acc.get_multi_ptr<sycl::access::decorated::no>().get()",63f1e29ba5a6cfd9dca80b2902e493d05d7e66c416f838ea9cdb1fad48074471,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-sycl/wkv.cpp,288,78,4,4,race,access,"This usually indicates a security flaw.  If an attacker can change anything along the path between the call to access() and the file's actual use (e.g., by moving files), the attacker can exploit the race condition (CWE-362/CWE-367!).","Set up the correct permissions (e.g., using setuid()) and try to open the file directly.",,CWE-362/CWE-367!,"                        item_ct1, (float*)shared_mem_acc.get_multi_ptr<sycl::access::decorated::no>().get()",63f1e29ba5a6cfd9dca80b2902e493d05d7e66c416f838ea9cdb1fad48074471,2.0.19,FF1030,https://cwe.mitre.org/data/definitions/362.htmlhttps://cwe.mitre.org/data/definitions/367.html
./ggml/src/ggml-vulkan/vulkan-shaders/vulkan-shaders-gen.cpp,147,9,4,4,shell,execl,This causes a new program to execute and is difficult to use safely (CWE-78).,try using a library call that implements the same functionality if available.,,CWE-78,"        execl(""/bin/sh"", ""sh"", ""-c"", command.c_str(), (char*) nullptr);",93240f5ae34f3a0f6dfefc0139ea6bc12f3902f22c28ff5c6e5e74fa8b74d896,2.0.19,FF1043,https://cwe.mitre.org/data/definitions/78.html
./ggml/src/ggml.c,174,9,4,4,shell,execlp,This causes a new program to execute and is difficult to use safely (CWE-78).,try using a library call that implements the same functionality if available.,,CWE-78,"        execlp(""gdb"", ""gdb"", ""--batch"",",3b5a1d03c22871254fdbe4dffa2a47bc55d30383ff0a4b31d2bfddd9a15009a3,2.0.19,FF1043,https://cwe.mitre.org/data/definitions/78.html
./ggml/src/ggml.c,182,9,4,4,shell,execlp,This causes a new program to execute and is difficult to use safely (CWE-78).,try using a library call that implements the same functionality if available.,,CWE-78,"        execlp(""lldb"", ""lldb"", ""--batch"",",949b6045814cf4b474daf16479770b6d8ac7dd7a348667b4655bbef1cec09ee3,2.0.19,FF1043,https://cwe.mitre.org/data/definitions/78.html
./ggml/src/ggml.c,222,5,4,4,format,vsnprintf,"If format strings can be influenced by an attacker, they can be exploited, and note that sprintf variations do not always \0-terminate (CWE-134).",Use a constant for the format specification.,,CWE-134,"    vsnprintf(message + offset, sizeof(message) - offset, fmt, args);",a2afd8815a440fad79f151ca9aa0c9eb67be1de6266ea4c157d59a9c52f2c9e4,2.0.19,FF1019,https://cwe.mitre.org/data/definitions/134.html
./ggml/src/ggml.c,255,15,4,4,format,vsnprintf,"If format strings can be influenced by an attacker, they can be exploited, and note that sprintf variations do not always \0-terminate (CWE-134).",Use a constant for the format specification.,,CWE-134,"    int len = vsnprintf(buffer, 128, format, args);",faae9dbf3118970fc0c81249e5912538ca8ae7f879563ef38e1a39eeb85f05ef,2.0.19,FF1019,https://cwe.mitre.org/data/definitions/134.html
./ggml/src/ggml.c,260,9,4,4,format,vsnprintf,"If format strings can be influenced by an attacker, they can be exploited, and note that sprintf variations do not always \0-terminate (CWE-134).",Use a constant for the format specification.,,CWE-134,"        vsnprintf(buffer2, len + 1, format, args_copy);",a5368f14a0797b328db91a020010b127d6a2083dc6d61e0ee4b7f036b60141f8,2.0.19,FF1019,https://cwe.mitre.org/data/definitions/134.html
./ggml/src/ggml.c,1816,5,4,4,format,vsnprintf,"If format strings can be influenced by an attacker, they can be exploited, and note that sprintf variations do not always \0-terminate (CWE-134).",Use a constant for the format specification.,,CWE-134,"    vsnprintf(tensor->name, sizeof(tensor->name), fmt, args);",aee0af51af4d787178ef4d9c5793d1bcb0b012c552d2ae157c87280105c9638e,2.0.19,FF1019,https://cwe.mitre.org/data/definitions/134.html
./ggml/tests/test-opt.cpp,16,29,4,4,format,printf,"If format strings can be influenced by an attacker, they can be exploited (CWE-134).",Use a constant for the format specification.,,CWE-134,#define TEST_LOG(...)       printf(__VA_ARGS__),51e029ba2ea40d5b592fd57feb85b7a932f4389ac97e0d0b5303570a66841598,2.0.19,FF1016,https://cwe.mitre.org/data/definitions/134.html
./ggml/tests/test-opt.cpp,175,5,4,4,format,printf,"If format strings can be influenced by an attacker, they can be exploited (CWE-134).",Use a constant for the format specification.,,CWE-134,"    printf(subtest_ok ? ""\033[1;32mOK\033[0m\n"" : ""\033[1;31mFAIL\033[0m\n"");",ac55c6829a06fbcaa445c2ee6e1246b3f353ebbeaf9cdcbb8889aaeb198b13d8,2.0.19,FF1016,https://cwe.mitre.org/data/definitions/134.html
./ggml/examples/mnist/mnist-common.cpp,485,5,3,3,random,srand,This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).,Use a more secure technique for acquiring random values.,,CWE-327,    srand(time(NULL));,8b68f2db5ddbab19e841f8d0aadcd9290b19776299593056419034cb4d359277,2.0.19,FF1048,https://cwe.mitre.org/data/definitions/327.html
./ggml/examples/mnist/mnist-eval.cpp,20,5,3,3,random,srand,This function is not sufficiently random for security-related functions such as key and nonce creation (CWE-327).,Use a more secure technique for acquiring random values.,,CWE-327,    srand(time(NULL));,8b68f2db5ddbab19e841f8d0aadcd9290b19776299593056419034cb4d359277,2.0.19,FF1048,https://cwe.mitre.org/data/definitions/327.html
./ggml/src/ggml-backend-reg.cpp,604,38,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    const char * backend_path = std::getenv(""GGML_BACKEND_PATH"");",77ec4343b9f883c019849aef32c8a6a043a25427e1d1829aac0b96ce580b1996,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-backend.cpp,1615,37,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    const char * GGML_SCHED_DEBUG = getenv(""GGML_SCHED_DEBUG"");",2be51400269f241fcd6da6ee1259f3fe22e7707e11731ebc2aa44d334f2f2191,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-cann/ggml-cann.cpp,103,28,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20",    const char* val = std::getenv(name.c_str());,07d2c97706f71867da31edd14f2ddea34111308a73b2c2fc17f101b860771755,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-cann/ggml-cann.cpp,1643,9,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    if (getenv(""GGML_CANN_NO_PINNED"") != nullptr) {",fca3f531688222febf91d0d23920fd97d506645486bd6fb4805d9cb45cd1ba15,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-cann/ggml-cann.cpp,2809,24,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    bool host_buffer = getenv(""GGML_CANN_NO_PINNED"") == nullptr;",5124606660d09573d9c39d33ff5ae86c4b7a7bd9dd42bfa8c9724c9f529d53d7,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-cpu/ggml-cpu.c,3563,18,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","            if (!getenv(""KMP_BLOCKTIME"")) {",c3bd54a7291cc5b93c8e27a31a2beabf57e4c3644dd0aa131c1c11b6e451fa6b,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-cpu/kleidiai/kleidiai.cpp,61,31,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","        const char *env_var = getenv(""GGML_KLEIDIAI_SME"");",3c1ac3a787daa250bf240c5a56c2a7f90c041b9de3aa41da9c8416ca070965d3,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,2075,40,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    char *      user_platform_string = getenv(""GGML_OPENCL_PLATFORM"");",6b9d264bd3b125257b5977f67e71fd2a4c4ce36fd7ccd61a8e15e95211c0f615,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,2076,40,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    char *      user_device_string   = getenv(""GGML_OPENCL_DEVICE"");",37500749ad6ace8036313a89db75bddf650b621b47ca623f28e466d52c237aa1,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,2414,35,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    backend_ctx->disable_fusion = getenv(""GGML_OPENCL_DISABLE_FUSION"") != nullptr;",09a6e24760a5fa263e727973620ee40c01987ecc5d64d06fd30caa526b70c177,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-rpc/ggml-rpc.cpp,34,38,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","static const char * RPC_DEBUG = std::getenv(""GGML_RPC_DEBUG"");",c5ac73bd39d787ef9622abbcfb3975e7904b786c0d04282eb55889f39f995446,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-sycl/common.cpp,23,7,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","  if (getenv(""GGML_SYCL_NO_PINNED"") != nullptr) {",c3fd140b6d2e71209287eb70b3aaa47125f0538815a87268ef825333601420d6,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-sycl/dpct/helper.hpp,915,25,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","            char* env = getenv(""ONEAPI_DEVICE_SELECTOR"");",1032cdeec6a70f95930ec77b60894cb240509a5fb6778475b6e8049c7d5b3519,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,180,32,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20",    char *user_device_string = getenv(env_name);,af7ffe0c1c915488f07211374924bb4894260f80801832c90460e721c15dab46,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,4129,24,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    bool host_buffer = getenv(""GGML_SYCL_NO_PINNED"") == nullptr;",d325003e6d80ec429be32275f1349e133cfdebf952b18c2a02d6206db37ebccd,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,3727,50,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","        const char* GGML_VK_PREFER_HOST_MEMORY = getenv(""GGML_VK_PREFER_HOST_MEMORY"");",39b333c811aa73c1d099c4b45538640dc17f995c78e207496c93114ed6aab868,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,3730,59,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","        const char* GGML_VK_DISABLE_HOST_VISIBLE_VIDMEM = getenv(""GGML_VK_DISABLE_HOST_VISIBLE_VIDMEM"");",09c8ae6036987befede8d436b44f45e38b9c08517993e000af433e7fc2fe91f2,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,3733,53,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","        const char* GGML_VK_ALLOW_SYSMEM_FALLBACK = getenv(""GGML_VK_ALLOW_SYSMEM_FALLBACK"");",c55eafd0f14d6b1f96074fb6b6e60713536e16cd8b478b3d565e261df408df96,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,3736,54,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","        const char* GGML_VK_DISABLE_GRAPH_OPTIMIZE = getenv(""GGML_VK_DISABLE_GRAPH_OPTIMIZE"");",e6e307eb1efa89959102859714e3f267d005db412f04140b813c102b94cb71cb,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,3768,25,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","                       !getenv(""GGML_VK_DISABLE_COOPMAT"")) {",b32de777ee231806d42fe81a8f31224f0c549d09f8204c5edc913fc209c8585c,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,3776,25,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","                       !getenv(""GGML_VK_DISABLE_COOPMAT2"")) {",a21e706ed511985dabf2038a37651216acbdb535735142df4e8d2d80b0c376d8,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,3781,25,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","                       !getenv(""GGML_VK_DISABLE_INTEGER_DOT_PRODUCT"")) {",ae122d31c7c3c6b063a77122d3d70d6ee887ea8cbcb0d9a0f55e2f5639f88469,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,3786,25,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","                       !getenv(""GGML_VK_DISABLE_BFLOAT16"")) {",0d6614131b03d2963a2c30bf8bb769c6697f3d1fe8424c41107504bd3711ec5c,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,3849,57,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","        const char* GGML_VK_FORCE_MAX_ALLOCATION_SIZE = getenv(""GGML_VK_FORCE_MAX_ALLOCATION_SIZE"");",10139277e194880c8b0190452fd19a07cd5f4a19457828d9552c04e5b65f564d,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,3859,56,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","        const char* GGML_VK_SUBALLOCATION_BLOCK_SIZE = getenv(""GGML_VK_SUBALLOCATION_BLOCK_SIZE"");",283a95c0dc2e680d27a9b69d4672e3d43c1394ea87f3eaa3788818f5f2ed2845,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,3896,40,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","        const bool force_disable_f16 = getenv(""GGML_VK_DISABLE_F16"") != nullptr;",38b4482014546fbfd9cab0f69978168728ac8064057dd8cdf1f1d523e3be06ca,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4043,29,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","                            getenv(""GGML_VK_DISABLE_MULTI_ADD"") == nullptr;",ebab7190b4a502e4c4720c5c4e3a054dec5317c9f3ddc970118c62adaa99fd5f,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4258,17,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","            if (getenv(""GGML_VK_DISABLE_BFLOAT16"")) {",b15dbd3d198bf0ef3de1801029a65da949691feedb85e3097da180373a81b593,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4357,34,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","        device->disable_fusion = getenv(""GGML_VK_DISABLE_FUSION"") != nullptr;",065624a424e7ec517f7f6e33bf8834a945488fd25a0a99361402b6f6b305cec7,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4366,13,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","        if (getenv(""GGML_VK_DISABLE_MMVQ"")) {",b29de24e6c18764b6f792f1055a37bd3327d29a6a3c10211a1e512618d20d96d,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4368,20,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","        } else if (getenv(""GGML_VK_FORCE_MMVQ"")) {",ec5ceeaaf2043fd751492eb9828ba9a4460d9f6f3f6d3968fb222e2429d0d091,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4408,21,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","                   !getenv(""GGML_VK_DISABLE_COOPMAT"")) {",b32de777ee231806d42fe81a8f31224f0c549d09f8204c5edc913fc209c8585c,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4413,21,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","                   !getenv(""GGML_VK_DISABLE_COOPMAT2"")) {",a21e706ed511985dabf2038a37651216acbdb535735142df4e8d2d80b0c376d8,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4418,22,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","                    !getenv(""GGML_VK_DISABLE_INTEGER_DOT_PRODUCT"")) {",ae122d31c7c3c6b063a77122d3d70d6ee887ea8cbcb0d9a0f55e2f5639f88469,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4423,22,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","                    !getenv(""GGML_VK_DISABLE_BFLOAT16"")) {",0d6614131b03d2963a2c30bf8bb769c6697f3d1fe8424c41107504bd3711ec5c,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4431,39,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    const char* GGML_VK_DISABLE_F16 = getenv(""GGML_VK_DISABLE_F16"");",de35b5ed10b5fbaf9f2267a35ccc741241e7cab35a50ea960dd2238702eef7f4,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4570,101,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    const bool debug_utils_ext = ggml_vk_instance_debug_utils_ext_available(instance_extensions) && getenv(""GGML_VK_DEBUG_MARKERS"") != nullptr;",94867fe5fa0992d016b5c8445f073881fa27ec7171f7e490b5a6771dcc972593,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4621,30,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    vk_perf_logger_enabled = getenv(""GGML_VK_PERF_LOGGER"") != nullptr;",2dd690d0a6a1e3931cc57119906670cf97d0aa64e266243a713eeef73656b82c,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4629,26,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    char * devices_env = getenv(""GGML_VK_VISIBLE_DEVICES"");",3db47e7ee8b66ce28d9075b64b0fc9a33da8ff98b8d85c91fd10078c54db980c,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4790,31,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    const char* skip_checks = getenv(""GGML_VULKAN_SKIP_CHECKS"");",4af07e477c93da81fc1d9c8c0873a88401f11bebd2fb5fd61aa4aee44fc8e5eb,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4792,33,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    const char* output_tensor = getenv(""GGML_VULKAN_OUTPUT_TENSOR"");",12157d7de64fd2cae195e4e3adb064aadf0abcefa27034cb2e5cd7c159f7596d,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml.c,134,38,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    const char * GGML_NO_BACKTRACE = getenv(""GGML_NO_BACKTRACE"");",a24011f2601a0a007c0449cf91e8dbf6502b739316ad21809d8aeb4475ca3395,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/src/ggml.cpp,17,38,3,3,buffer,getenv,"Environment variables are untrustable input if they can be set by an attacker.  They can have any content and length, and the same variable can be set more than once (CWE-807, CWE-20).",Check environment variables carefully before using them.,,"CWE-807, CWE-20","    const char * GGML_NO_BACKTRACE = getenv(""GGML_NO_BACKTRACE"");",a24011f2601a0a007c0449cf91e8dbf6502b739316ad21809d8aeb4475ca3395,2.0.19,FF1053,https://cwe.mitre.org/data/definitions/807.html
./ggml/examples/common-ggml.cpp,35,35,2,2,integer,atoi,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,        ftype = (enum ggml_ftype) atoi(str);,549b02c833407ba441152378e514217bf0f3f2e12e32cc3e809e5242a2b3511b,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/examples/common.h,196,18,2,2,misc,open,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"            file.open(filename, std::ios::binary);",6fdd1ec7d56db723e43bbb44d93346d2366b25e1b1812fd4d8375b8f07a860bb,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/examples/common.h,204,10,2,2,misc,open,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"    bool open(const std::string & filename,",52800c1b265cf5bfceb31eebf6fd31e0998c10e760bb0c6e00b96b8ccd717ede,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/examples/gpt-2/main-alloc.cpp,369,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(model.lm_head->data, tensor->data, ggml_nbytes(tensor));",70acf96ebbcc1ba4dccabebedf511c80271b1cc1a3171fc403bd2b34f7382a8a,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,694,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(embd->data, embd_inp.data(), N*ggml_element_size(embd));",23fd9674fc3994691b3d53b2ca7859fd131c00b19f2eda6cc8dd108abc528f48,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,721,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(embd_w.data(), (float *) ggml_get_data(logits) + (n_vocab*(N-1)), sizeof(float)*n_vocab);",376302e6649975620da5f843a1e35984c999a31864c093c0d682f36290675000,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,366,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(model.lm_head->data, tensor->data, ggml_nbytes(tensor));",70acf96ebbcc1ba4dccabebedf511c80271b1cc1a3171fc403bd2b34f7382a8a,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,435,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(embd->data, embd_inp.data(), N*ggml_element_size(embd));",23fd9674fc3994691b3d53b2ca7859fd131c00b19f2eda6cc8dd108abc528f48,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,685,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(embd_w.data(), (float *) ggml_get_data(inpL) + (n_vocab*(N-1)), sizeof(float)*n_vocab);",e189a60b76bb69dce7592b2e8674c950a3690d4cb094ae16430dd455cc23ab7e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,439,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(embd->data, embd_inp.data(), N*ggml_element_size(embd));",23fd9674fc3994691b3d53b2ca7859fd131c00b19f2eda6cc8dd108abc528f48,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,606,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(embd_w.data(), (float *) ggml_get_data(inpL) + (n_vocab*(N-1)), sizeof(float)*n_vocab);",e189a60b76bb69dce7592b2e8674c950a3690d4cb094ae16430dd455cc23ab7e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/magika/main.cpp,137,16,2,2,misc,fopen,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"    FILE * f = fopen(fname.c_str(), ""rb"");",be2a3bd527fc0d01510697ac1ec674f642cd6ba25098589753d371d07e3fdc87,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/examples/magika/main.cpp,271,20,2,2,misc,fopen,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"        FILE * f = fopen(fnames[i].c_str(), ""rb"");",0401734da652eb61d3c46435ed917c32a14e76e93eba97cbd0339dae065e0aef,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/examples/perf-metal/perf-metal.cpp,26,21,2,2,integer,atoi,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,        n_op = std::atoi(argv[1]);,ae977cde1f0386cc29fcab28c9ed127ac35926ae4251a44ed8f26cc6aac6f1a1,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/examples/perf-metal/perf-metal.cpp,30,23,2,2,integer,atoi,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,        n_iter = std::atoi(argv[2]);,43d4a36b2959ac3d9573ad2befc36530df6c155081480c55ec27f9b814dc7162,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/examples/sam/sam.cpp,428,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(img.data.data(), data, nx * ny * 3);",7a5152ef24c9ff3434bda06ed2fd03a7e7dd99c0e1b547a7b85b9c2e9f04631c,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/simple/simple-ctx.cpp,46,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(model.a->data, a, ggml_nbytes(model.a));",3607c0cc5cc05266046859d8aa008a98849355aefb4d84fee39917f3145f2017,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/simple/simple-ctx.cpp,47,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(model.b->data, b, ggml_nbytes(model.b));",225514ec57c95f7d46e59d10cce69b696ebbd5074c35ff3795f49707bb167120,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/simple/simple-ctx.cpp,105,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(out_data.data(), result->data, ggml_nbytes(result));",131af045dd2312c56688abc7423e11b7e70a7f15ebe8993806f8641f0e996039,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,653,18,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];,c00fe3e0ca65b3a38c97f2a54f83517aad167fbdc0149503725ae6f72174973d,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image.h,1234,10,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"         memcpy(temp, row0, bytes_copy);",c64d5ecfb4c5f84d84ecda79a3b4bffcda4f343b26e12a0ab83136976f4d31bf,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,1235,10,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"         memcpy(row0, row1, bytes_copy);",89fb836982dab6642322925501030e4a144638f98f7d683a9fe591c2e34dd2f3,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,1236,10,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"         memcpy(row1, temp, bytes_copy);",4bc91d94a1425291ea42389ff3768e43e9b9f2f7194551626ed4979bc115ecfa,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,1324,49,2,2,buffer,MultiByteToWideChar,"Requires maximum length in CHARACTERS, not bytes (CWE-120).",,,CWE-120,"STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);",532b0ba6d2e33aceb33882781ebddd1bba07337e05d3f472d07357df21c6b4f5,2.0.19,FF1023,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,1339,4,2,2,buffer,wchar_t,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,   wchar_t wMode[64];,0aa9d9ae470034f5240c862ac37e15ec191393ee1a953de458f9855e1ee48d70,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image.h,1340,4,2,2,buffer,wchar_t,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,   wchar_t wFilename[1024];,1424ade1769c8ece3716067bf43762ab418a56552fed003d5451130595ee5280,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image.h,1341,11,2,2,buffer,MultiByteToWideChar,"Requires maximum length in CHARACTERS, not bytes (CWE-120).",,,CWE-120,"	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))",0c075646f55e62a1fbef1d3f128cda01ca4af500ac966a7bcc5ffc0237b0df70,2.0.19,FF1023,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,1344,11,2,2,buffer,MultiByteToWideChar,"Requires maximum length in CHARACTERS, not bytes (CWE-120).",,,CWE-120,"	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))",e4dbb388da362a48a892f60d318677cd8fca0ad95a1835d60cd651ab4b305565,2.0.19,FF1023,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,1358,8,2,2,misc,fopen,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"   f = fopen(filename, mode);",8c460646fad176770cda1fd5e2f211cf12413175982cd93e5ef42ad029cef0dd,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/examples/stb_image.h,1671,10,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"         memcpy(buffer, s->img_buffer, blen);",954fc5f1bd313efa3384ec3746b8b50da8c36072030d73f4d1e8cc0e3798ba47,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,1681,7,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"      memcpy(buffer, s->img_buffer, n);",8954fc8b6778ba35b12f7e1cfd381dd27c705f5819cf63ded7f4c58fbc290839,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,3167,32,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,"         static const unsigned char tag[5] = {'J','F','I','F','\0'};",3d63da1530091e74fb7d9564177a09bf9040289fcf6eb7f84e06a8f00f6727ea,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image.h,3177,32,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,"         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};",8303fa218c03db523c713c2fc014f936dbabb36fd57dbf34744979b62645bc75,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image.h,3284,29,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,"      static const unsigned char rgb[3] = { 'R', 'G', 'B' };",cf9cb5ec85c773cb24d781b1e65fc3f6f8eeb707e00ec2e8967bac8aad0cb494,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image.h,4411,4,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"   memcpy(a->zout, a->zbuffer, len);",ed750af6d7d4b405c1b29f99aad59eb410dfdfeaf849a55b18d652b583cb4136,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,4736,40,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            case STBI__F_none:         memcpy(cur, raw, nk); break;",a4cda42b9b31569b90c4d143fc961c36cf4c290a29ad8abe8bd7779c50062afd,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,4893,16,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,",33124fa47677f33621b37353b0dacc783da9bdb2ed585e9ea936d77242eadf2c,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,5892,13,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,   unsigned char raw_data[4] = {0};,5373d500a4b362c606b2388cc2c89299243736d39329ce32d58023464aaa15fd,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image.h,6817,16,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );",1a30fdb5b661ed1e2bafc0daafd6353578250b278401d1fc71062e3dd1dd2898,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,6824,16,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );",937614764150f0e674625b2863814abaf7049c9b714e805110bd967d6298f124,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,6835,7,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"      memcpy( g->background, g->out, 4 * g->w * g->h );",bfcee2678e60f10a2a61f3dd3017c4cd0af419bfdd900bf90f4130c3ab6c60ff,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,6899,22,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );",89c6d11af8ab938ba24e66e8070357b9f7933d42a06731e08af601e1104025ab,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,7020,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy( out + ((layers - 1) * stride), u, stride );",a01e8e221294e85f7c09798155742d36a68305a9b50a242850ca083670280d05,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,7159,4,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,   char buffer[STBI__HDR_BUFLEN];,a2a65fe3a4deb4bee30ca36f40c0f7917db1607704df54dd5b2e2bb69cb24305,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image.h,7290,4,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,   char buffer[STBI__HDR_BUFLEN];,a2a65fe3a4deb4bee30ca36f40c0f7917db1607704df54dd5b2e2bb69cb24305,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image_write.h,271,13,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,   unsigned char buffer[64];,5a7522c829f03b67276ee4f7c5878b37aa1ec8223cd4e048d86ad39df9d959aa,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image_write.h,295,50,2,2,buffer,MultiByteToWideChar,"Requires maximum length in CHARACTERS, not bytes (CWE-120).",,,CWE-120,"STBIW_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);",6c82dc944640b8aa1e75c15c6c0026e59df50d8479be6ec12c130b559e924589,2.0.19,FF1023,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image_write.h,308,4,2,2,buffer,wchar_t,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,   wchar_t wMode[64];,0aa9d9ae470034f5240c862ac37e15ec191393ee1a953de458f9855e1ee48d70,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image_write.h,309,4,2,2,buffer,wchar_t,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,   wchar_t wFilename[1024];,1424ade1769c8ece3716067bf43762ab418a56552fed003d5451130595ee5280,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image_write.h,310,13,2,2,buffer,MultiByteToWideChar,"Requires maximum length in CHARACTERS, not bytes (CWE-120).",,,CWE-120,"   if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))",0c075646f55e62a1fbef1d3f128cda01ca4af500ac966a7bcc5ffc0237b0df70,2.0.19,FF1023,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image_write.h,313,13,2,2,buffer,MultiByteToWideChar,"Requires maximum length in CHARACTERS, not bytes (CWE-120).",,,CWE-120,"   if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))",e4dbb388da362a48a892f60d318677cd8fca0ad95a1835d60cd651ab4b305565,2.0.19,FF1023,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image_write.h,327,8,2,2,misc,fopen,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"   f = fopen(filename, mode);",8c460646fad176770cda1fd5e2f211cf12413175982cd93e5ef42ad029cef0dd,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/examples/stb_image_write.h,358,31,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,                     unsigned char b[2];,608b360404147bfffa86ab88adeaf37c470ecebc0448b2f6db4fdb33b0776ade,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image_write.h,364,31,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,                     unsigned char b[4];,f2a4baf5156353ab7660d6c625101d7361903043061a1c673bfa9cf2f768d22d,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image_write.h,420,13,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,"   unsigned char bg[3] = { 255, 0, 255}, px[3];",75afd21fed4d416b07f3de983bd9bce580847e820107a9c746fa862096d74d64,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image_write.h,674,13,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,"   unsigned char scanlineheader[4] = { 2, 2, 0, 0 };",0b7143d712eed348feb5c6e9d1202051aff7a16ba474ac7a5a0b480e1079990d,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image_write.h,675,13,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,   unsigned char rgbe[4];,f778c4d9e9ba24cbc5ba9d6a9daf8d387fc65e5a0ea24c758eae445e88f94793,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image_write.h,769,7,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,      char buffer[128];,bbb368e12028053051f7e7a8cae6a0668c5084d93a02908e0f475627036496c7,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image_write.h,776,13,4,2,buffer,sprintf,Does not check for buffer overflows (CWE-120).,"Use sprintf_s, snprintf, or vsnprintf.",Risk is low because the source has a constant maximum length.,CWE-120,"      len = sprintf(buffer, ""EXPOSURE=          1.0000000000000\n\n-Y %d +X %d\n"", y, x);",1aafd285387bfd327c58d62e4def9f772f6b9f4edaba3d5d81208791862860a1,2.0.19,FF1015,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image_write.h,995,10,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"         memcpy(out+stbiw__sbn(out), data+j, blocklen);",e5459a748cc033b72b6b09d0ce0507d17ce1fb5a8b2cb2a6183bddee116765f0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image_write.h,1103,7,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"      memcpy(line_buffer, z, width*n);",83b49b219527ef0e034cd3edda084eae829a9cff339c5ab9a9f11fbc6e90d036,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image_write.h,1132,13,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,"   unsigned char sig[8] = { 137,80,78,71,13,10,26,10 };",6a7b2b76e7fca6ece376f96d8876749368316982e438a2f9fb08d72fee03552f,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/stb_image_write.h,1472,13,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,"   unsigned char YTable[64], UVTable[64];",7c84cb713697ab8eead060bdcf377a67a6a27e006ebd7399c7b950fac5d35af4,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/yolo/yolov3-tiny.cpp,123,9,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,        char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/examples/yolo/yolov3-tiny.cpp,159,13,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,            char fname[256];,ea99843bd5fe5e87b49f4ca24790fa6c5253c99e89b6d5e8987a24a3e077f5b5,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/include/ggml.h,650,9,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,        char name[GGML_MAX_NAME];,1a55484bae218b06b850288868d209f3aaae0ccf755fc7d2ab9950128dddd776,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/include/ggml.h,654,9,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,        char padding[8];,5c8c65887cbbd0f4222178d12cf43b7383b9e787c8bf82e1b682e2af972b60d5,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-backend.cpp,767,8,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,static char causes[GGML_DEFAULT_GRAPH_SIZE*16 + GGML_SCHED_MAX_SPLITS_DEBUG*GGML_SCHED_MAX_SPLIT_INPUTS][128]; // debug only,86f73c86db1403a6c4d15ae2cd67a783002631cd0323fb3e9cb1335c3901a437,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-backend.cpp,834,12,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    static char buffer[128];,26dc56e4d21bed123911238e4d2c1057e0eb63290be5213a83c2cf48c5855133,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-backend.cpp,1616,39,2,2,integer,atoi,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,    sched->debug = GGML_SCHED_DEBUG ? atoi(GGML_SCHED_DEBUG) : 0;,06dde42268171307e9cd6b8b739f73eaa5162c26992410f86a7cdac1c1424134,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/src/ggml-backend.cpp,2089,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy((char *)tensor->data + offset, data, size);",f47ea8438f74d72418a2ec0149037691f4080c0af7fac7f1aba99f56e3b8b1f9,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-backend.cpp,2096,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(data, (const char *)tensor->data + offset, size);",5f4f83127881f1082c15919f9653d570126742581f0094ff3d74a4dd8397b0ae,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-backend.cpp,2104,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(dst->data, src->data, ggml_nbytes(src));",9756cf1ca1de2cf11e916984c1ec411d70a867f3fe266691007a36fb4368996b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/acl_tensor.h,99,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(tmp_ne, ne, dims * sizeof(int64_t));",67151836a95ee995086b147e9b8f621274c5fdbd428e93bd8c001cc0d6c17715,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,286,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&negative_slope, dst->op_params, sizeof(float));",333d269d216cce02eae4a4526913fa678c60c50c944c522e3a4313aad2870d02,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,369,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&start, (float*)dst->op_params + 0, sizeof(float));",0f6b8818fcbf3debfb24d8c08a54691c4deb20c19a5f416c7da7db0bf431ec9f,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,370,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&stop, (float*)dst->op_params + 1, sizeof(float));",1551493a7f4fe0e87ead721828ceca102342308bdc2b1200bd5636785248e6bd,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,371,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&step, (float*)dst->op_params + 2, sizeof(float));",802302b257d9b0e324d60397b4f5ddae6cd7f9fba127b3cafd980a12db04ead8,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,382,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&min, dst->op_params, sizeof(float));",4fd04b05d12c1a0679292198dbe1b19b9624248ef266665a9e794be6b6f0f43b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,383,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&max, (float*)dst->op_params + 1, sizeof(float));",d1214b8eef865e6b8eb48b44fb43f959195a6e5ad34a32240fd89d8a530fd231,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,400,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&v, dst->op_params, sizeof(float));",07f9b02d67418c62152da766cc3eac91e5296bcb2a881f44f6a5236d20ea24c1,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,435,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, dst->op_params, sizeof(float));",67d1dcfaab93c7d3db5d61cc3421ea72b1cf69937f5149cf665bab2888facbad,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,453,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, dst->op_params + 1, sizeof(float));",d2da7d1499b69146f2c6c4a55ccd4b9d80794f2042855d211b9d62890d05a152,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,966,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, dst->op_params, sizeof(float));",67d1dcfaab93c7d3db5d61cc3421ea72b1cf69937f5149cf665bab2888facbad,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,1645,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&scale, (float *) dst->op_params + 0, sizeof(float));",0de6e2b61f9c2dd931ae94cdd27bcbf51aa5feec5f255a19c257b8a5a3ff4252,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,1646,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&max_bias, (float *) dst->op_params + 1, sizeof(float));",85bf428474678e08b49c8664fc5d87d690e57520b5273c596fc2a51d968ff218,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,2543,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&freq_base, (int32_t*)dst->op_params + 5, sizeof(float));",8e3c24b8e73eef1a14c0fc76cd27be0f614b2a82a4789fc3449781183eb8dad0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,2544,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&freq_scale, (int32_t*)dst->op_params + 6, sizeof(float));",3bafe03be431c3e12b4013fe35c026be7265c02315ce0832f3c7991fd4961eba,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,2545,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&ext_factor, (int32_t*)dst->op_params + 7, sizeof(float));",136e2b95f39fbb261ea8a51154e7608e9d790b35d143c437f8f06ef1dc27ae96,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,2546,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&attn_factor, (int32_t*)dst->op_params + 8, sizeof(float));",ddf089e86a02760074dd4ad47f19774556b15b871329f946e6b48e8026d20d2b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,2547,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&beta_fast, (int32_t*)dst->op_params + 9, sizeof(float));",81c4cb8cb8f49e3f603a2ebab1d0d987c80d9c42c4a24ce1f5721f2b37059a17,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,2548,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&beta_slow, (int32_t*)dst->op_params + 10, sizeof(float));",cdecaf624d637e3f3b2f03bd9178d3c79680f47da655dbca516e2e2d42e556df,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,3142,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(src0_bsnd_ne, src0->ne, GGML_MAX_DIMS * sizeof(int64_t));",25fd67acf0946b9a0a9437f0fb8a41baf660a1aca2af2f089b703fdb809890b5,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,3144,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(src0_bsnd_nb, src0->nb, GGML_MAX_DIMS * sizeof(size_t));",2a8d5a4d79604d93b4297ecb05932e345b0e963c43d1185c56cde76ff05c9831,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,3146,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(src1_bsnd_ne, src1->ne, GGML_MAX_DIMS * sizeof(int64_t));",b2fd756ffc0d2dfd47708cc41e313a2700e9156670d0ef5b5794405236e43d00,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,3148,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(src1_bsnd_nb, src1->nb, GGML_MAX_DIMS * sizeof(size_t));",bbeb88a342e85bb7684d5b33d0f33c76119f716b60e84721054d358d310827a3,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,3150,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(src2_bsnd_ne, src2->ne, GGML_MAX_DIMS * sizeof(int64_t));",d16bf49e7fcaae871bea977f765e6e01da1b055ad71d7d07e941c0179264cb64,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,3152,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(src2_bsnd_nb, src2->nb, GGML_MAX_DIMS * sizeof(size_t));",2a98b32fd6152627846befeb9a129da50244e761cb1e31c17daa0fcdc108ba61,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,3170,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&scaleValue,    (float*)dst->op_params + 0, sizeof(float));",d1c1c7a9754de5fea609d053168a179902ae08005b95bb55942ffa0764217831,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,3171,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&maxBias,       (float*)dst->op_params + 1, sizeof(float));",51ef9500745ed49e914e4d22941a8e008fb16ab8246b9590a0b29f9bd361a39f,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,3172,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&logitSoftcap,  (float*)dst->op_params + 2, sizeof(float));",aa39625edaab50c1b6a71d95c802e915615b3bf527268d8d9b1cc93e53ff8d53,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/aclnn_ops.cpp,3328,9,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,"        char layout[5] = {'B', 'S', 'N', 'D', 0};",cdf3e66a6fefd27b1e800fdc7ec0015c113dfaf313fe9a23ad2fc85dbb71463b,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cann/ggml-cann.cpp,994,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(quant_offset, group->qs, group_quant_size);",8b5bf69fc86d2bc3278245f438d700502576027893c0a63f93b862563ddd95d5,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/ggml-cann.cpp,1027,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(group->qs, quant_offset, group_quant_size);",6f47e8d7fcda974c204eec8f3c38756b21e3658be7766a10b657e5ca5594bb89,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/ggml-cann.cpp,2192,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(prop.op_params, node->op_params, GGML_MAX_OP_PARAMS);",bc7796c66f0b438e79cbdb1021473582ddfcaac01fc9a1925c1b42adc66379cc,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/ggml-cann.cpp,2616,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(&bias, (const float *)(op->op_params) + 1, sizeof(float));",97af341b3caf528be168d844b1166e23a8f68ff6601e09631a8cec9aa3a0cabf,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cann/ggml-cann.cpp,2652,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(&logitSoftcap, (const float *)(op->op_params) + 2, sizeof(float));",10823db6b1847df1954e5c597bb0c1faece0229590d6e9b04691f2b4c9235e03,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/amx/amx.cpp,73,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy((char *) tensor->data + offset, data, size);",738b6212cf31bf73fb4b3298cc7ed925b61e2830bb4529cef40c02eab59700ff,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/amx/mmq.cpp,836,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(utmp, scales, 12);",79024228e8efa12b96624561589ef2b986aa454c6494e4bb7fd6710b8e14f77e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/arm/quants.c,1793,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(aux, x[i].scales, 12);",34eac8d3d898c76ff4ba62d5099825209954286589377027aed04eab5ecd7a17,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/arm/quants.c,1975,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(aux, x[i].scales, 12);",34eac8d3d898c76ff4ba62d5099825209954286589377027aed04eab5ecd7a17,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/arm/quants.c,2092,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(scales_mins, x0->scales, 12);",7722a7eb74b8cdb4a2c661a8446177b408f9c32abe3e059200188bd3dffe683a,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/arm/quants.c,2100,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(x0_scales, scales, 8);",dc0e8f9fd2dd0eec93a03b62588cf8e890f32d099286e14091e9b7fbbdb5d3c8,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/arm/quants.c,2104,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(scales_mins, x1->scales, 12);",c2fffcc1e6ca3417f987f0a0c57d2b139c7703f67be9d21b83164e8671bf21da,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/arm/quants.c,2112,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(x1_scales, scales, 8);",8544a641b9dd659fe111a52375be105121104b0d2f512f78f03933679981e91d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/arm/quants.c,2219,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, K_SCALE_SIZE);",f0130cc0699ffb6b2fd7d8e788fe89883b49a13fe21e2313c1d1d79e18e364c3,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/arm/quants.c,2307,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/arm/quants.c,2403,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/arm/quants.c,2994,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(aux32, q2, 4*sizeof(uint32_t)); q2 += 8;",89c115cc396d8686acd29fe824b4a40efd7246a42df2fbed9c75face84f966cf,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/arm/quants.c,3226,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(aux32, gas, 2*sizeof(uint32_t)); gas += 2*sizeof(uint32_t);",d91aa00957179db80431c6659784511cf9d4fa290446de2a42152a7b1d75c1ca,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/arm/quants.c,3308,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(scales32, x[i].scales, 4);",64c3b47ec98c58069fd8a417bc80fedca38640810849bab9eee4b930c2a7d782,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/loongarch/quants.c,386,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&x32, x, sizeof(uint32_t));",38f7021632b86c7b51540649905ef5511edcaf42e20d93f72e7a7b1f9b68eb4d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/loongarch/quants.c,1101,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(aux, x[i].scales, 12);",34eac8d3d898c76ff4ba62d5099825209954286589377027aed04eab5ecd7a17,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/loongarch/quants.c,1203,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/loongarch/quants.c,1303,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/loongarch/quants.c,1522,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(aux32, q2, 4*sizeof(uint32_t)); q2 += 8;",89c115cc396d8686acd29fe824b4a40efd7246a42df2fbed9c75face84f966cf,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/loongarch/quants.c,1571,18,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    static const char block_sign_shuffle_mask_1[32] = {,e9d571266a40ef67fb1c28c0a82d10a7ba798052a4876ff6d6a30f6659e526a5,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cpu/arch/loongarch/quants.c,1575,18,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    static const char block_sign_shuffle_mask_2[32] = {,261561668645a3534a15dba8faac56361be9048e2d3c259190a5d9c3f449d63b,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cpu/arch/loongarch/quants.c,1609,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&aux64, x[i].scales, 8);",5bb5eb4f5ad8ef7231ecfab2b4f0bb4cad3f3473bdfdc0e64eb2b64eddbe6a22,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/loongarch/quants.c,1734,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&aux64, x[i].scales, 8);",5bb5eb4f5ad8ef7231ecfab2b4f0bb4cad3f3473bdfdc0e64eb2b64eddbe6a22,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/loongarch/quants.c,1825,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(aux32, gas, 8); gas += 8;",ee159b7ca6e2ab7da64d58ed5c96726ee2fc9d41da1abba5321c63aab48bb9cb,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/powerpc/quants.c,1466,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(aux32, q2, 4*sizeof(uint32_t));",436c2935c5600cc45b6c59ffab86fd262a96537a45738cfb1204a3b34d575eff,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/riscv/quants.c,839,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(aux, x[i].scales, 12);",34eac8d3d898c76ff4ba62d5099825209954286589377027aed04eab5ecd7a17,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/riscv/quants.c,1216,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/riscv/quants.c,1513,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/s390/quants.c,753,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(aux, x[i].scales, 12);",34eac8d3d898c76ff4ba62d5099825209954286589377027aed04eab5ecd7a17,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/s390/quants.c,881,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/s390/quants.c,995,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/wasm/quants.c,784,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(auxs, x[i].scales, 12);",5abaa43147eed98ea853f04574d2dfac7f1d6ab7f71318f220040f3900166466,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/wasm/quants.c,878,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/wasm/quants.c,1011,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/cpu-feats.cpp,127,9,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,        char vendor[0x20] = {};,9746b672d896d45ca193c8e348b0face2bb6bce70d81c4747878acbc7ecee5e8,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cpu/arch/x86/cpu-feats.cpp,171,9,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,        char brand[0x40] = {};,dc05f462995afaa8294fe73d2c28981b608985df265fe8631c82bd677162f282,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cpu/arch/x86/cpu-feats.cpp,173,18,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            std::memcpy(brand, ext_data[2].data(), sizeof(cpui));",213477ad91885a76af77c8bd575694af648e0f7f3accacef3e848a79aade4510,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/cpu-feats.cpp,174,18,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            std::memcpy(brand + 16, ext_data[3].data(), sizeof(cpui));",b61585904c20759389be48d44ef5b3e5fe897b92074968da755db55cda56cef8,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/cpu-feats.cpp,175,18,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            std::memcpy(brand + 32, ext_data[4].data(), sizeof(cpui));",100f15f4b4ab8fb77bb495939ad1a7ef52f8292734952fa405146653ad37f457,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/quants.c,78,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&x32, x, sizeof(uint32_t));",38f7021632b86c7b51540649905ef5511edcaf42e20d93f72e7a7b1f9b68eb4d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/quants.c,182,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&x32, x, sizeof(uint32_t));",38f7021632b86c7b51540649905ef5511edcaf42e20d93f72e7a7b1f9b68eb4d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/quants.c,1503,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(aux, x[i].scales, 12);",34eac8d3d898c76ff4ba62d5099825209954286589377027aed04eab5ecd7a17,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/quants.c,1772,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/quants.c,1841,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/quants.c,1955,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/quants.c,2036,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/quants.c,2401,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(aux32, q2, 4*sizeof(uint32_t)); q2 += 8;",89c115cc396d8686acd29fe824b4a40efd7246a42df2fbed9c75face84f966cf,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/quants.c,2446,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(aux32, q2, 4*sizeof(uint32_t)); q2 += 8;",89c115cc396d8686acd29fe824b4a40efd7246a42df2fbed9c75face84f966cf,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/quants.c,2505,18,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    static const char block_sign_shuffle_mask_1[32] = {,e9d571266a40ef67fb1c28c0a82d10a7ba798052a4876ff6d6a30f6659e526a5,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cpu/arch/x86/quants.c,2509,18,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    static const char block_sign_shuffle_mask_2[32] = {,261561668645a3534a15dba8faac56361be9048e2d3c259190a5d9c3f449d63b,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cpu/arch/x86/quants.c,2543,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&aux64, x[i].scales, 8);",5bb5eb4f5ad8ef7231ecfab2b4f0bb4cad3f3473bdfdc0e64eb2b64eddbe6a22,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/quants.c,2622,18,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    static const char block_sign_shuffle_mask_1[32] = {,e9d571266a40ef67fb1c28c0a82d10a7ba798052a4876ff6d6a30f6659e526a5,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cpu/arch/x86/quants.c,2626,18,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    static const char block_sign_shuffle_mask_2[32] = {,261561668645a3534a15dba8faac56361be9048e2d3c259190a5d9c3f449d63b,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cpu/arch/x86/quants.c,2664,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&aux64, x[i].scales, 8);",5bb5eb4f5ad8ef7231ecfab2b4f0bb4cad3f3473bdfdc0e64eb2b64eddbe6a22,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/quants.c,2825,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&aux64, x[i].scales, 8);",5bb5eb4f5ad8ef7231ecfab2b4f0bb4cad3f3473bdfdc0e64eb2b64eddbe6a22,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/quants.c,2898,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&aux64, x[i].scales, 8);",5bb5eb4f5ad8ef7231ecfab2b4f0bb4cad3f3473bdfdc0e64eb2b64eddbe6a22,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/quants.c,3007,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(aux32, gas, 8); gas += 8;",ee159b7ca6e2ab7da64d58ed5c96726ee2fc9d41da1abba5321c63aab48bb9cb,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/quants.c,3056,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(aux32, gas, 8); gas += 8;",ee159b7ca6e2ab7da64d58ed5c96726ee2fc9d41da1abba5321c63aab48bb9cb,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/repack.cpp,111,12,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    int i; memcpy(&i, &val, sizeof(int));",49dae36a52ad749c679059bd28911d0aec1e7a0851dc6bb02bdb4c7939571b7b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/repack.cpp,1503,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(utmp_0, b_ptr[b].scales + 24 * sb, 12);",266f9a8a381dafb14f7459f14c59bee6ce93c39ce922dc2eef624d01d35d7771,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/repack.cpp,1511,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(utmp_1, b_ptr[b].scales + 12 + sb * 24, 12);",952f97850116336d273f9865dc5d5f50d5efef5827913cd8b205fc50141ccac6,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/repack.cpp,2143,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(utmp_00, b_ptr_0[b].scales + 24 * sb, 12);",780e3e711cec8e2a5d2a732893b08c05c3f3670ccd3af9ad5bc944092d21c6cb,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/repack.cpp,2151,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(utmp_01, b_ptr_0[b].scales + 12 + sb * 24, 12);",60799cdf494d62b63efff824d2995b870f981aea667d089203e978c185dc925c,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/repack.cpp,2158,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(utmp_10, b_ptr_1[b].scales + sb * 24, 12);",e5ec912bca3dc0728a23991ff089042cda5dd9eeae8e7310b13daf4324abe6b9,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/repack.cpp,2166,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(utmp_11, b_ptr_1[b].scales + 12 + sb * 24, 12);",98109bdf2b70d80929ca2ca4db73001b20e2ee6c34ff7107269f5d8f028888a5,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/repack.cpp,2506,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(utmp_00, b_ptr_0[b].scales + 24 * sb, 12);",780e3e711cec8e2a5d2a732893b08c05c3f3670ccd3af9ad5bc944092d21c6cb,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/repack.cpp,2514,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(utmp_01, b_ptr_0[b].scales + 12 + sb * 24, 12);",60799cdf494d62b63efff824d2995b870f981aea667d089203e978c185dc925c,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/repack.cpp,2522,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(utmp_10, b_ptr_1[b].scales + sb * 24, 12);",e5ec912bca3dc0728a23991ff089042cda5dd9eeae8e7310b13daf4324abe6b9,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/repack.cpp,2530,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(utmp_11, b_ptr_1[b].scales + 12 + sb * 24, 12);",98109bdf2b70d80929ca2ca4db73001b20e2ee6c34ff7107269f5d8f028888a5,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/repack.cpp,2872,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(utmp_0, b_ptr[b].scales + 24 * sb, 12);",266f9a8a381dafb14f7459f14c59bee6ce93c39ce922dc2eef624d01d35d7771,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/repack.cpp,2880,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(utmp_1, b_ptr[b].scales + 12 + sb * 24, 12);",952f97850116336d273f9865dc5d5f50d5efef5827913cd8b205fc50141ccac6,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/repack.cpp,3204,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(utmp_0, b_ptr[b].scales + 24 * sb, 12);",266f9a8a381dafb14f7459f14c59bee6ce93c39ce922dc2eef624d01d35d7771,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/arch/x86/repack.cpp,3212,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(utmp_1, b_ptr[b].scales + 12 + sb * 24, 12);",952f97850116336d273f9865dc5d5f50d5efef5827913cd8b205fc50141ccac6,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ggml-cpu.c,602,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char path[256];,b4d831b0f784c4e1a00031255f8b7a7c7e79406a11614a941b1a04036df30bd4,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cpu/ggml-cpu.c,666,22,2,2,misc,fopen,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"        FILE *fptr = fopen(""/proc/sys/kernel/numa_balancing"", ""r"");",e16a5ed2d8c3c25604913c636a1c6d383c495b87b5800cc265987bec218b09d0,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/src/ggml-cpu/ggml-cpu.c,668,13,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,            char buf[42];,7a2c44275e98a4acc2595772294ced54243c79fc04db7ce0f9ee12d9f01b87ee,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cpu/ggml-cpu.c,1198,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(&dst_col[iir0 + cn * nb1 / nb0], tmp + (cn * 16), (MIN(iir0 + blck_0, ir0_end) - iir0) * sizeof(float));",8b303e8ccd4bf29abd81798cb67675e507160aa93d2b0a59a645a683299565ad,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ggml-cpu.c,1465,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(&dst_col[iir0], tmp, (MIN(iir0 + blck_0, ir0_end) - iir0)*sizeof(float));",bbc83153a667a1eb71435635724f799dc6577b50fc7cf2a55ee62b1ed093af83,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ggml-cpu.c,1525,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char (*atomic_current_chunk)[CACHE_LINE_SIZE] = // [n_as],592829e0a32b0fac94e5552108b0686af304adeab39002f16d10bb9b3b4b7e53,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cpu/ggml-cpu.c,2575,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(local_mask, global_mask, GGML_MAX_N_THREADS);",5c136070ab437cfebed31197b7415b5deeeb254832ed9a5b69d7b71bd2a112d4,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ggml-cpu.c,3211,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(y, x, n * sizeof(float));",25d60947b6a58c3d88f523d5032a3544baa607c2bc2fdfbf805a9577ed3f6ad0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ggml-cpu.cpp,286,20,2,2,misc,fopen,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"        FILE * f = fopen(""/proc/cpuinfo"", ""r"");",897896cb80360d0915fe264e5ec50925ba990e92a8e7a0ec8125451a4dfe025d,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/src/ggml-cpu/ggml-cpu.cpp,288,13,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,            char buf[1024];,5065f5757ec562d76d80e513ac33668b30265995d34290fc3fe7083c178c0622,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cpu/ggml-cpu.cpp,446,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(&max_bias, (const float *) op->op_params + 1, sizeof(float));",487710819196c46f62b7fd1bd49a23025eb2db4427016812a7e7b80ac766c605,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/kleidiai/kleidiai.cpp,69,27,2,2,integer,atoi,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,            sme_enabled = atoi(env_var);,22f9be68a29ae214ed7eba32dd7e2c1d2bfa938f610ac3ad0b9a44b198080b75,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/src/ggml-cpu/llamafile/sgemm.cpp,998,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&x32, b->qh, sizeof(uint32_t));",3a5d9a32d827ae7e5ca2745b1000a266885a3bcf87e86debec08366cf4c66f70,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/llamafile/sgemm.cpp,1011,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&x32, b->qh, sizeof(uint32_t));",3a5d9a32d827ae7e5ca2745b1000a266885a3bcf87e86debec08366cf4c66f70,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/llamafile/sgemm.cpp,1056,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&x32, p, sizeof(uint32_t));",277ce749ad976d7e55170dc3700b5bdaf54ec5447d1539ea45e1724dbdb5f2dd,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/llamafile/sgemm.cpp,1157,25,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,        vector unsigned char c_arr[8];,afaf41fd1619aa0a8cb225be8687b7ab712a9784d6af2eedc5a58b389b5b52f1,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cpu/llamafile/sgemm.cpp,1670,23,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,"        vector signed char c1[2] = {0}, c2[2] = {0}, c3[2] = {0}, c4[2] = {0};",185add58a459999c84af07b108d0efde5637a405f68807154a705595aadaf1f5,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cpu/llamafile/sgemm.cpp,1671,23,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,"        vector signed char c5[2] = {0}, c6[2] = {0}, c7[2] = {0}, c8[2] = {0};",4c4e4499bfb7dae0f2c75dffe725c5f6c960424c596edc6a3c0bb8e05040cf4a,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-cpu/ops.cpp,37,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,        memcpy(,73c0ba8f0821f4619d5216dce2de72bf69ab6cc8b31403138b7f1466ac4258f0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,76,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,                    memcpy(,73c0ba8f0821f4619d5216dce2de72bf69ab6cc8b31403138b7f1466ac4258f0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,100,29,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                            memcpy(dst_ptr + id, src0_ptr, rs);",632fc4e9ffb1f166aad5588d33cd507e514a1c9c1113600b75b9360c0c3464b4,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,178,25,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                        memcpy(dst_ptr, src0_ptr, sizeof(dst_t));",7b10a16846bb92defaa2ed4fe6f3b0292d06d159481f7b0f08a8dd0b77a69b08,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,360,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,                    memcpy(,73c0ba8f0821f4619d5216dce2de72bf69ab6cc8b31403138b7f1466ac4258f0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,382,25,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                        memcpy(dst_ptr + id, src0_ptr, rs);",632fc4e9ffb1f166aad5588d33cd507e514a1c9c1113600b75b9360c0c3464b4,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,397,29,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                            memcpy(dst_ptr + id, src0_ptr, type_size);",a6fa237a83eddc5c8cce6dea2d70a510fe5a3bf9f04bec0b1ee7689009a94b70,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,440,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(dst_ptr, src0_ptr, type_size);",df274c5e762bbffb32d0b778761c5b12350dc5e92ef4c5142e453251d45cd7a8,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,647,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(dst_row, wdata, ne0*nb0);",27b7173d231791d7bd0b281a69a073ef4d8a2018a8946045b183410968b6e7e4,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,1170,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,            memcpy(,73c0ba8f0821f4619d5216dce2de72bf69ab6cc8b31403138b7f1466ac4258f0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,1875,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(y, x, len);",fe53a05dfe81b89366b2d77413eaafad9500029322196b6df1482ed540975031,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,2471,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&negative_slope, dst->op_params, sizeof(float));",333d269d216cce02eae4a4526913fa678c60c50c944c522e3a4313aad2870d02,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,2501,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&negative_slope, dst->op_params, sizeof(float));",333d269d216cce02eae4a4526913fa678c60c50c944c522e3a4313aad2870d02,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,3466,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, dst->op_params, sizeof(float));",67d1dcfaab93c7d3db5d61cc3421ea72b1cf69937f5149cf665bab2888facbad,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,3537,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, dst->op_params, sizeof(float));",67d1dcfaab93c7d3db5d61cc3421ea72b1cf69937f5149cf665bab2888facbad,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,3556,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(y, x, ne00 * sizeof(float));",5b8339c0cc6c448ec80fa9e488426060cf6f72379bdb74a33d71dd7948925baa,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,3608,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, dst->op_params, sizeof(float));",67d1dcfaab93c7d3db5d61cc3421ea72b1cf69937f5149cf665bab2888facbad,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,3785,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, dst->op_params + 1, sizeof(float));",d2da7d1499b69146f2c6c4a55ccd4b9d80794f2042855d211b9d62890d05a152,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,3878,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, dst->op_params, sizeof(float));",67d1dcfaab93c7d3db5d61cc3421ea72b1cf69937f5149cf665bab2888facbad,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,3895,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(y, x, ne00 * sizeof(float));",5b8339c0cc6c448ec80fa9e488426060cf6f72379bdb74a33d71dd7948925baa,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,4198,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&s, (float *) dst->op_params + 0, sizeof(float));",29363ecfb1e1294190ff9e240f4302d353f386b397011990239481a88de56edb,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,4199,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&b, (float *) dst->op_params + 1, sizeof(float));",f65acbc61381373e084db20469db8fad0ba801a0cb75060d657ae97ffb43a5e0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,4223,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy((char *)dst->data + i1*nb1, (char *)src0->data + i1*nb01, nc * sizeof(float));",a380114f33810071fed115a8da33c8c477deadfdfdbed35caa990fc0656aaf85,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,4279,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,            memcpy(,73c0ba8f0821f4619d5216dce2de72bf69ab6cc8b31403138b7f1466ac4258f0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,4350,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,            memcpy(,73c0ba8f0821f4619d5216dce2de72bf69ab6cc8b31403138b7f1466ac4258f0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5009,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,            memcpy(,73c0ba8f0821f4619d5216dce2de72bf69ab6cc8b31403138b7f1466ac4258f0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5090,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&scale,    (float *) dst->op_params + 0, sizeof(float));",2243a950d1b5f5237d8b1fa6335b5835654e49428dc12ac7acb8ef7f3fd6ff82,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5091,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&max_bias, (float *) dst->op_params + 1, sizeof(float));",85bf428474678e08b49c8664fc5d87d690e57520b5273c596fc2a51d968ff218,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5225,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&scale,    (const float *) dst->op_params + 0, sizeof(float));",2c0aa7493162422c7813257b75bc78a086942f9d994cef0912a5e03ffc9cf4e4,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5226,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&max_bias, (const float *) dst->op_params + 1, sizeof(float));",ae510229c0d7587627d2d184577d1e30939e5903392d80bfb4b4eb407e363019,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5321,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&min, (float *) dst->op_params + 0, sizeof(float));",737d0faca55a902d390bbdfe597c6879f6e6390c177a9ce8a796a2f96cb6ce25,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5322,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&max, (float *) dst->op_params + 1, sizeof(float));",445acdc843b1aef85f408f7da4b95c5bcbf354dbed4013646e0b3acaa2b65579,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5357,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&min, (float *) dst->op_params + 0, sizeof(float));",737d0faca55a902d390bbdfe597c6879f6e6390c177a9ce8a796a2f96cb6ce25,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5358,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&max, (float *) dst->op_params + 1, sizeof(float));",445acdc843b1aef85f408f7da4b95c5bcbf354dbed4013646e0b3acaa2b65579,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5556,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&freq_base,   (int32_t *) dst->op_params +  5, sizeof(float));",da59b27e119ace3916db1ca45730dcad4511767e0f0c0b5dc4106101bc8fde60,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5557,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&freq_scale,  (int32_t *) dst->op_params +  6, sizeof(float));",0011a16f7f018110b2594dd3a7fb63ddf044ca048804765d80c46d171dbc2537,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5558,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&ext_factor,  (int32_t *) dst->op_params +  7, sizeof(float));",3cd25261f2b7ff40aa3ed89f0744d42641dc93a8c62b9e31a83237a38dd1e50e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5559,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&attn_factor, (int32_t *) dst->op_params +  8, sizeof(float));",2bd63996bf3ba47baca25e957f490e18933e9fe7a2315cacec608ad7b1ea1874,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5560,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&beta_fast,   (int32_t *) dst->op_params +  9, sizeof(float));",dd400931e67d5ffb6294bff6b0bd22c7e882db5826f6503ce1ef96b9105f8eff,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5561,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&beta_slow,   (int32_t *) dst->op_params + 10, sizeof(float));",4b857c4bd4e0be4313eb4f295814bb891d49d9476b2dec13f2dd090150bb9b27,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5562,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&sections,    (int32_t *) dst->op_params + 11, sizeof(int)*4);",6e663edb77fe594df823a6d51c5575a0ae6b91df9fe1bb2630db10c2944c26e1,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5741,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&freq_base,   (int32_t *) dst->op_params +  5, sizeof(float));",da59b27e119ace3916db1ca45730dcad4511767e0f0c0b5dc4106101bc8fde60,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5742,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&freq_scale,  (int32_t *) dst->op_params +  6, sizeof(float));",0011a16f7f018110b2594dd3a7fb63ddf044ca048804765d80c46d171dbc2537,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5743,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&ext_factor,  (int32_t *) dst->op_params +  7, sizeof(float));",3cd25261f2b7ff40aa3ed89f0744d42641dc93a8c62b9e31a83237a38dd1e50e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5744,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&attn_factor, (int32_t *) dst->op_params +  8, sizeof(float));",2bd63996bf3ba47baca25e957f490e18933e9fe7a2315cacec608ad7b1ea1874,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5745,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&beta_fast,   (int32_t *) dst->op_params +  9, sizeof(float));",dd400931e67d5ffb6294bff6b0bd22c7e882db5826f6503ce1ef96b9105f8eff,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5746,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&beta_slow,   (int32_t *) dst->op_params + 10, sizeof(float));",4b857c4bd4e0be4313eb4f295814bb891d49d9476b2dec13f2dd090150bb9b27,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,5747,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&sections,    (int32_t *) dst->op_params + 11, sizeof(int)*4);",6e663edb77fe594df823a6d51c5575a0ae6b91df9fe1bb2630db10c2944c26e1,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,7985,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&scale,         (float *) dst->op_params + 0, sizeof(float));",bc7cb6334ff15375fc628b2c8cbac94f83e04db7a8e168022e46f02d87abe357,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,7986,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&max_bias,      (float *) dst->op_params + 1, sizeof(float));",fab8b62416c9827481c04f253f02e130e85e6be58bb9e5ab4845499b5571cf23,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,7987,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&logit_softcap, (float *) dst->op_params + 2, sizeof(float));",82ed2092f86b4967f4dc3cec7daca868ab90e5d34a06e01d10b3b27f4a4b4e0d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,8150,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy((char *) dst->data + (i3*ne2*ne1 + i2 + i1*ne1)*nb1, VKQ32, nb1);",132a1cb52caf24ec3a65b6590b66a34a2ac22c6d4fea8bec16cc3cf6b2ad79ad,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ops.cpp,9107,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy((char *) dst->data, (char *) src0->data, ggml_nbytes(dst));",018f10e8598acdb98952b0ad61254e3549937535067e5d584e4bd553cddfa9f4,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/quants.c,529,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(auxs, x[i].scales, 12);",5abaa43147eed98ea853f04574d2dfac7f1d6ab7f71318f220040f3900166466,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/quants.c,590,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/quants.c,670,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(utmp, x[i].scales, 12);",8c14598d295ec31d32921520ac40beb41c256c1c3af915ddb5b0525fb1c6d95d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/quants.c,783,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(aux32, q2, 2*sizeof(uint32_t));",d7d4b9aae34bd80a36ab19f9f9866d5c4a0a9ba219efed44423c83ec6cafd883,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/quants.c,927,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(&aux32, gas, sizeof(uint32_t)); gas += sizeof(uint32_t);",0053f50ac1af28d40580c65a52205c1eae0df5f2f5afd551687feeecab696b27,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/repack.cpp,30,12,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    int i; memcpy(&i, &val, sizeof(int));",49dae36a52ad749c679059bd28911d0aec1e7a0851dc6bb02bdb4c7939571b7b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/repack.cpp,375,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(utmp + sb * 4, b_ptr[l].scales + sb * 12, 12);",0f43004dd74cebc6a80e48b68b744b5c41e458b1a645420b481d3c34cbe81337,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/repack.cpp,772,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(utmp + sb * 4, b_ptr[l].scales + sb * 12, 12);",0f43004dd74cebc6a80e48b68b744b5c41e458b1a645420b481d3c34cbe81337,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/repack.cpp,1030,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(&elems, &in[src_id].qs[src_offset], sizeof(uint64_t));",3a8e2fa71dcc3664ead8e3fa36fc402e720d4490084527d45d471137a7eb0274,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/repack.cpp,1032,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(&out.qs[dst_offset], &elems, sizeof(uint64_t));",fe4ba14160bdbdbe48ae7afe0e0dfdce83cebccf504fee780ef30c435ef0af9e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/repack.cpp,1042,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(&elems, &in[src_id].qs[src_offset], sizeof(uint32_t));",3d01638f4131223f0a4fbf257edc26e4866ce994b1a61b1781652ff46f8a06f5,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/repack.cpp,1044,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(&out.qs[dst_offset], &elems, sizeof(uint32_t));",b35445673aa827be1115fc9be746baf3fea24c9dd28bff0d48426d8725faf644,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/repack.cpp,1073,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&elems, &in[src_id].qs[src_offset], sizeof(uint64_t));",3a8e2fa71dcc3664ead8e3fa36fc402e720d4490084527d45d471137a7eb0274,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/repack.cpp,1075,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&out.qs[dst_offset], &elems, sizeof(uint64_t));",fe4ba14160bdbdbe48ae7afe0e0dfdce83cebccf504fee780ef30c435ef0af9e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/repack.cpp,1101,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&elems, &in[src_id].qs[src_offset], sizeof(uint64_t));",3a8e2fa71dcc3664ead8e3fa36fc402e720d4490084527d45d471137a7eb0274,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/repack.cpp,1102,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&out.qs[dst_offset], &elems, sizeof(uint64_t));",fe4ba14160bdbdbe48ae7afe0e0dfdce83cebccf504fee780ef30c435ef0af9e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/repack.cpp,1178,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&elems, &in[src_id].qs[src_offset], sizeof(uint64_t));",3a8e2fa71dcc3664ead8e3fa36fc402e720d4490084527d45d471137a7eb0274,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/repack.cpp,1179,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&out.qs[dst_offset], &elems, sizeof(uint64_t));",fe4ba14160bdbdbe48ae7afe0e0dfdce83cebccf504fee780ef30c435ef0af9e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/repack.cpp,1350,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(&out.qs[dst_offset], &in[src_id].qs[src_offset], sizeof(uint32_t));",d005252aed22d6c3ecfe6894966edc6c2d4b55ff7d43acd753bbb22a7bc729aa,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/repack.cpp,1407,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(&out.qs[dst_offset], &in[src_id].qs[src_offset], sizeof(uint64_t));",2435e0fca027cd486c72fdb334e569e71f35c224dd1598a896a19c3c1b47e1d6,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/simd-mappings.h,50,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&tmp, &h, sizeof(ggml_fp16_t));",dc95ebeb503a8501a73179fbf314f2b115113181b8c11c2d3115dcfb5628e24f,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/simd-mappings.h,57,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&res, &tmp, sizeof(ggml_fp16_t));",66868ba4d4e9655da4672502d67e074671ab4573959bc60fba95e304868eda7f,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/simd-mappings.h,102,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&hf, &h, sizeof(ggml_fp16_t));",97b9bcc660f3c877cf54945c1f721b7881aa9a3c5593bcd05fdd3221e87bd499,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/simd-mappings.h,109,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&res, &hf, sizeof(ggml_fp16_t));",bf8539f818eaa54296692454df2aeecc592f7f2a647c2fef3da85fb41f1cb978,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/simd-mappings.h,129,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&s, &f, sizeof(uint16_t));",2b287639ca1bbb4d659e878755308a52f24720d13a3dc2c08863514644b5504e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/simd-mappings.h,963,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&a, x, sizeof(ggml_fp16_t) * 8);",313df9913830733ad7d69773f53d6132fbcdaa5818e675ed063e63d330e91c7c,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/simd-mappings.h,971,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(x, &a, sizeof(ggml_fp16_t) * 8);",b097965bd5e301b108b5b1af5f7b7f79aa0bd7666650759e60b74487ec934ec1,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/spacemit/ime.cpp,605,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&epsilon, dst->op_params, sizeof(float));",1731567e608ed0dd3f1018a708f22bec9c4bde4c15f5a96a8cc77c8dcf103dd8,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/spacemit/ime.cpp,730,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&epsilon, dst->op_params, sizeof(float));",1731567e608ed0dd3f1018a708f22bec9c4bde4c15f5a96a8cc77c8dcf103dd8,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/spacemit/ime.cpp,834,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t->data, data, data_size);",61175d6576ee7b09d5baa381ffe9b2640fc5e84899c70074ea3f9bf9d703e323,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/vec.h,900,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(&t, &fp16, sizeof(uint16_t));",ea288483d5e9fc262d5c47d6b8144a4fb1d08f48564d1e28c44e687b0ee076e4,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/vec.h,936,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&t, &fp16, sizeof(uint16_t));",ea288483d5e9fc262d5c47d6b8144a4fb1d08f48564d1e28c44e687b0ee076e4,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/vec.h,1334,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(&t, &fp16, sizeof(uint16_t));",ea288483d5e9fc262d5c47d6b8144a4fb1d08f48564d1e28c44e687b0ee076e4,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/vec.h,1385,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&t, &fp16, sizeof(uint16_t));",ea288483d5e9fc262d5c47d6b8144a4fb1d08f48564d1e28c44e687b0ee076e4,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-impl.h,145,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(tensor->op_params, params, params_size);",db0cc1e85eeed45a26faf999199e8fb27018af89c284f2274b58f027e67342b0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-impl.h,462,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&result, &bits, sizeof(float));",acbf0d5e7e2b652d8484eef5607365d534bd4836a44149a78a15668d2cc9a193,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-impl.h,484,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&result, &bits, sizeof(float));",acbf0d5e7e2b652d8484eef5607365d534bd4836a44149a78a15668d2cc9a193,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,61,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,62,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,85,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,86,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,112,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,113,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,129,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,130,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,146,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,147,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,163,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,164,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,182,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,183,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,240,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,241,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,274,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,275,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,305,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,306,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,338,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,339,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,355,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,356,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,378,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,379,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,418,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,419,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,442,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,443,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,478,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,479,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,651,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,652,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,672,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,673,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,705,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,706,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,875,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,876,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,896,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,897,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,931,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,932,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,990,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,991,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1046,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1047,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1076,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1077,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1112,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1113,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1135,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1136,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1158,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1159,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1201,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1202,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1241,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1242,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1266,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1267,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1285,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1286,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1304,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1305,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1323,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1324,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1342,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1343,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1361,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char base[256];,b64ae3becde623df5c1495b46380defd56ad743490a843d6f47b147caf425b82,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.cpp,1362,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[256];,19c62a8ddc5a4443fedfdd576821b20b2ef7bed16768540672622dabf32627c6,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-device.h,168,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[128];,46132eacf231df987674de8924ebd73264789288957c93f364cfd2ec4f2b1218,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,667,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&scale, ((const int32_t *) op->op_params) + 0, sizeof(float));",4ec5435a61fa39c37665f9bedb9ed33847f715577eef561aeccd5dfb72593fb4,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,668,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&bias,  ((const int32_t *) op->op_params) + 1, sizeof(float));",b0f8a57cf7f391069e821098ef8eb923bdf4c01044c0fe801dea29c611287304,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,706,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&min, ((const int32_t *) op->op_params) + 0, sizeof(float));",d71a526697093e38eea4b161d5930a219c4ed0dd8b3b4b04cd85b5c22bfe4b71,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,707,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&max, ((const int32_t *) op->op_params) + 1, sizeof(float));",81375b80f1b54a45170fa1f4ab8ad8de18056f75a7626439652da93ad7e6bb30,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,2391,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, op->op_params, sizeof(float));",81d30188fe6d250e002cd919919f6b9bc5415416b282c15cd38c919177d73971,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,2441,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, op->op_params + 1, sizeof(float));",2825c7e53de9749ee86bbe7d3eb8c93cfd3a7c812569c8c6bb9065530a454150,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,2494,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, op->op_params, sizeof(float));",81d30188fe6d250e002cd919919f6b9bc5415416b282c15cd38c919177d73971,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,2648,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&freq_base,   (const int32_t *) op->op_params +  5, sizeof(float));",d9f4f798d6570ed25db1a3a2ca750c66574b3e5adeed945986c55516158e4170,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,2649,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&freq_scale,  (const int32_t *) op->op_params +  6, sizeof(float));",1c731067633aff6dd1869a0358bdbf1f0ee2dbbf84bb5b7304077db31f01bbce,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,2650,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&ext_factor,  (const int32_t *) op->op_params +  7, sizeof(float));",6d5c7ab34b481d76aca7f3b9fcb51117465351bda3e3c9cfc531e2cefbb54e7f,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,2651,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&attn_factor, (const int32_t *) op->op_params +  8, sizeof(float));",c1b623d3418f8c730dd2d60259c70ee9ff3cc12e940829475a415bd31dab8a4f,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,2652,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&beta_fast,   (const int32_t *) op->op_params +  9, sizeof(float));",b3c04f70314fa7d7dee2f559150c876acf0b69624af85a2d9660cd434074cb2a,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,2653,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&beta_slow,   (const int32_t *) op->op_params + 10, sizeof(float));",01c060dabf6a61d4ff4a2ec7aa2ec45c50679ec7bcaf693a9e6f4577cbec4013,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,2981,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&start, ((const int32_t *) op->op_params) + 0, sizeof(float));",d2874bd0cf2007d37317373a5c4008d863e67bf14ec8889a065abdcdabcde17e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,2982,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&step,  ((const int32_t *) op->op_params) + 2, sizeof(float));",0481bede8ab4154408126fb71c19673092d72c629d2b051b853ac91910d5d3ad,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-metal/ggml-metal-ops.cpp,3136,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&slope, op->op_params, sizeof(float));",50438ab7de34e8d5757a3d478ffef85a27103ea2c34014be7b09ce254ccdbe10,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,230,22,2,2,integer,atoi,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"    int major = std::atoi(compiler_ver_str.substr(compiler_major_offset, 2).c_str());",a197c8b34263d91804904a836659d249dfe68f14ac839ef923a57defe10ffa81,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,231,22,2,2,integer,atoi,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"    int minor = std::atoi(compiler_ver_str.substr(compiler_minor_offset, 2).c_str());",8a1cc832fd69c2b719e4e662916c31ae38108927d79495662bb5cf0557b35c22,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,232,22,2,2,integer,atoi,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"    int patch = std::atoi(compiler_ver_str.substr(compiler_patch_offset, 2).c_str());",0096e55e0d06c96214e3ac86a8e7781538776dd2b6877b8cf3c3c9e6bdb9a92b,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,487,24,2,2,misc,fopen,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"        FILE * fperf = fopen(""cl_profiling.csv"", ""w"");",9a3e99a63185c455958853655f2b15beec3f8edb0f6f395ec3110b6e38008e4d,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,514,13,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,            char kernel_name[512];,91f5e00d879c362be63806fe9fa0181ade8b006eb97adc27b132cae2b0adfae2,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,552,24,2,2,misc,fopen,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"        FILE* ftrace = fopen(""cl_trace.json"", ""w"");",406e14ca2bf7d5ffd013cd22a3fb4f92d95a85473b4e2895ff3ff458cf4c1f25,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,2002,9,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,        char name[128];,46132eacf231df987674de8924ebd73264789288957c93f364cfd2ec4f2b1218,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,2003,9,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,        char vendor[128];,92d55f119fceef1b42d552a8e93a900deac1eacc0b0ef8fe3b7ac8dce75bc753,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,2014,9,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,        char name[128];,46132eacf231df987674de8924ebd73264789288957c93f364cfd2ec4f2b1218,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,2015,9,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,        char version[128];,186fbea31504fcc9d42e5657edc4e277a73aeeb2300c050900ae6694a8e73084,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,4122,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char fname[512];,700c19ba83fb57e05993763e8fc20228cd3dcf132756b64112e88bca15e4a940,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,4124,16,2,2,misc,fopen,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"    FILE * f = fopen(fname, ""w"");",7fd87c03bac5923540a910378f2a7b3f09f18b8cf6e93cb743a5adb2e0c7bb10,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,5275,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&min, ((int32_t *) dst->op_params) + 0, sizeof(float));",4c7158c9ebee3102bc014e0dfebed8c1092927a3885ac2055346be8838b48949,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,5276,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&max, ((int32_t *) dst->op_params) + 1, sizeof(float));",70f2a980c0dcca0178259876ecb1d38ca0e06d31b41a988867c8bd860ae4ce03,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,5317,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, dst->op_params, sizeof(float));",67d1dcfaab93c7d3db5d61cc3421ea72b1cf69937f5149cf665bab2888facbad,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,5372,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, dst->op_params, sizeof(float));",67d1dcfaab93c7d3db5d61cc3421ea72b1cf69937f5149cf665bab2888facbad,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,5461,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, rms_norm_tensor->op_params, sizeof(float));",34217306d87e51b8916acbcd6c5db2d2f42b5007cdb44df7b624b8c96436d30f,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,5559,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, norm_tensor->op_params, sizeof(float));",eb350bae5db8dc6f7c3a9bfd943604be1f8a54db0da9418c82a6eb80af4ca77a,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,5646,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&groups, gn_tensor->op_params, sizeof(int));",6f7668106e96a8679f4c6532196d4212f9b4bd96351367cbbd1a7c43a19e65a6,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,5647,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, (char *)gn_tensor->op_params + sizeof(int), sizeof(float));",e7ff80f1adaa2642fd12b8f1556f5602337be45762ab64ef87d9519b3ea1f1b2,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,7705,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&scale, ((int32_t *) dst->op_params) + 0, sizeof(float));",68a0e09fa6b9f1c699d0cec0f23735efed35c7f9444f08e86b1863ae285d5f29,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,7706,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&bias,  ((int32_t *) dst->op_params) + 1, sizeof(float));",e5e108b9b949cbcb62a8155f869eb59bb72c9e6772e83c402594bc89da159e1b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,7959,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&scale,    dst->op_params + 0, sizeof(float));",46a2d37af9ba794c4c10dbe5cc2727876c5c6e60a2c17b77c9ad60f2c661fccb,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,7960,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&max_bias, dst->op_params + 1, sizeof(float));",52911b1c69f203a924096558cf3ca0f18329c1ac846e4284e27f89f9e69e5e1f,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,8098,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&freq_base,   (int32_t *) dst->op_params + 5, sizeof(float));",8c3ca999a88188919c3749699348ce51d92def4f3dfd050af8350d170ae985d7,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,8099,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&freq_scale,  (int32_t *) dst->op_params + 6, sizeof(float));",e8f444b1fed5f332f49ad747212896a33da08b7c548109aa04f08c99b06f0427,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,8100,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&ext_factor,  (int32_t *) dst->op_params + 7, sizeof(float));",7dc7b81c9c0deb9f9e994afa15067deef017625d0784dda2285011ec845fb35c,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,8101,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&attn_factor, (int32_t *) dst->op_params + 8, sizeof(float));",884251c6e79b3a91a3e0ecde282e96a6004c790242fd2ea07238e4827809e343,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,8102,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&beta_fast,   (int32_t *) dst->op_params + 9, sizeof(float));",eb94843bfb01149c8def221cf8dc60ac9c9ca692db957a31be78b9f8bde1da14,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,8103,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&beta_slow,   (int32_t *) dst->op_params + 10, sizeof(float));",4b857c4bd4e0be4313eb4f295814bb891d49d9476b2dec13f2dd090150bb9b27,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,8104,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&sections,    (int32_t *) dst->op_params + 11, sizeof(int32_t)*4);",1b9fb68a0ee54082180dc87334d1a7df946aa4655630bcb8e382a1afb6284e0f,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opt.cpp,209,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(ptr_data_batch, ptr_data, dataset->nbs_data);",292c58be2f0b1111d8fc6a73a39c0c070fd8b39cfb6f8ee080b1259ff092c7da,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opt.cpp,217,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(ptr_labels_batch, ptr_labels, dataset->nbs_labels);",27a18f5b9de875a1d661bc9eb8784b887b6574cc73a7d7e8e7f55f370dc405e8,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opt.cpp,279,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(new_tensor->op_params, tensor->op_params, sizeof(tensor->op_params));",3cc3d4fe80365ec3585e301f4a88dfdf27c0336e14d4bf5d1eecf5bd619b6385,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-quants.c,150,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&y[i].qh, &qh, sizeof(qh));",6a475dc1ee7e30cc1fce95a7c3e6237858535e1f6ce3718530fca73acdafc431,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-quants.c,447,12,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    int i; memcpy(&i, &val, sizeof(int));",49dae36a52ad749c679059bd28911d0aec1e7a0851dc6bb02bdb4c7939571b7b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-quants.c,1146,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(aux, x[i].scales, 12);",34eac8d3d898c76ff4ba62d5099825209954286589377027aed04eab5ecd7a17,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-quants.c,2016,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&y[ib].qh, &qh, sizeof(qh));",d562418cc9570687ede2cb6a4bdb90cfbca55ddc9f2fcb751a5e431fef5da2c6,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-quants.c,2069,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(&y[ib].qh, &qh, sizeof(qh));",d562418cc9570687ede2cb6a4bdb90cfbca55ddc9f2fcb751a5e431fef5da2c6,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-quants.c,2287,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(aux32, x[i].qs + 4*ib32, 2*sizeof(uint32_t));",5801912b72808594d24b67ce947fb9ec4aa2983f02282dac2da361aacd1d3b5a,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-quants.c,2375,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(&aux32, scales_and_signs + 4*ib32, sizeof(uint32_t));",4be955c5d58153be2a3f84afe04bd8021148bce021a49b3c186b91d451f8f197,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-quants.c,3133,21,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    memcpy(L, Laux, 32);",a0c94b03c37f2a53e061a20ecff339c8d01ad959d1f5352e00bfc9accbbd10ca,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-quants.c,3199,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(y[ibl].qs, q2, QK_K/4);",720195d1fd4ec89cfc44e9c730b324d7bc5f252b7060ae7f80f5311755fd9da5,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-quants.c,3378,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(y[ibl].qs, q2, QK_K/4);",720195d1fd4ec89cfc44e9c730b324d7bc5f252b7060ae7f80f5311755fd9da5,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-quants.c,3830,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(qs, q3, quant_size);",aa741da291ea3f01e1705235bce3d759f929da3d98e32c4cc48cd8edd72be4dd,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-rpc/ggml-rpc.cpp,84,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[GGML_MAX_NAME];,1a55484bae218b06b850288868d209f3aaae0ccf755fc7d2ab9950128dddd776,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-rpc/ggml-rpc.cpp,86,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char padding[4];,50660a4f45b64d02d4ccb1b9830e455800a8be898dcf0c064610e4a7df29804d,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-rpc/ggml-rpc.cpp,284,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&addr.sin_addr.s_addr, server->h_addr, server->h_length);",dbb70b2570c0cc60a700953a65b3f4c47619ace58b49864c969966b60305c70e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-rpc/ggml-rpc.cpp,594,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(input.data(), &rpc_tensor, sizeof(rpc_tensor));",e569c9af9fadc89c4bced801fd4565b264a8c86685799f29497dcae2ac113537,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-rpc/ggml-rpc.cpp,595,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(input.data() + sizeof(rpc_tensor), &offset, sizeof(offset));",b13cf98d2fb38c5f06408196e5499861e870364c7b0b56e17cfa589111e37f59,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-rpc/ggml-rpc.cpp,596,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(input.data() + sizeof(rpc_tensor) + sizeof(offset), data, size);",bc4f7880c560b00de6c40b3c09b7c6c8b52adb51afa7b9608581a994a268d48f,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-rpc/ggml-rpc.cpp,769,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(output.data(), &n_nodes, sizeof(n_nodes));",76c624879589f0c17ad99f4c6ca634da41e94527d2cc3a196c31116d6a7d1dc9,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-rpc/ggml-rpc.cpp,771,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(output.data() + sizeof(n_nodes) + i * sizeof(uint64_t), &cgraph->nodes[i], sizeof(uint64_t));",39ac46054c721506d2b9de86f40eac925eb649777a3a3f00a8ca9da9fe326552,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-rpc/ggml-rpc.cpp,776,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(out_tensors, tensors.data(), n_tensors * sizeof(rpc_tensor));",56a3e69af18e23996dbc9c9b1a9ab38aa9f0adff854e10d30c0416c8ae970ee9,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-rpc/ggml-rpc.cpp,1099,9,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,        char hash_str[17];,19037cef39aac49a55fe93f6bafdf52dc9f04a2d35c123846ff3e0612e5a0c92,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-rpc/ggml-rpc.cpp,1115,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char hash_str[17];,19037cef39aac49a55fe93f6bafdf52dc9f04a2d35c123846ff3e0612e5a0c92,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-sycl/concat.cpp,181,48,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            SYCL_CHECK(CHECK_TRY_ERROR(stream->memcpy(dst_d, src0_d, size0).wait()));",d445f9ecb9d8470ba38b37317d693e9b97f0c6e7b5638ac59bfe43920170657d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/concat.cpp,182,48,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            SYCL_CHECK(CHECK_TRY_ERROR(stream->memcpy(dst_d + size0 / 4, src1_d, size1).wait()));",f6c2698b6d1ef82f82382297636d18769d751c073560e541ef953fc498670822,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/cpy.cpp,530,22,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        main_stream->memcpy(src1_ddc, src0_ddc, ggml_nbytes(src0));",ed1adbc076bc9eb3fcb8c0b6d05e24f9c7c1eaa16240586c71676b9294c0bb52,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/cpy.hpp,147,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(dsti->qh, &qh, sizeof(qh));",f886edc6a0c9f22754bfed9b0870ee4c264ed7b5d1bceea0726c877e271ad362,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/cpy.hpp,181,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(dsti->qh, &qh, sizeof(qh));",f886edc6a0c9f22754bfed9b0870ee4c264ed7b5d1bceea0726c877e271ad362,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/dpct/helper.hpp,402,22,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                std::memcpy(_name, name, length + 1);",b03d6f6f9568ec53d85ab7903a95cac6579302b0b4b85284f2247107f8415a16,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/dpct/helper.hpp,406,22,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                std::memcpy(_name, name, 255);",2fc3da01fdc9415b9035861ae2bd13daa7568974f917c913d2da300782b9d398,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/dpct/helper.hpp,495,9,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,        char _name[256];,a22e621c0e014a69fca8d316046e633b5ad0b613ac6ecc82bc9ddbaeee98d96b,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-sycl/dpct/helper.hpp,1436,22,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            return q.memcpy(to_ptr, from_ptr, size, dep_events);",8ed9a6523ce1194f6a3253a992145afdc9361da68dd13bfae125e1d10ea4e8c3,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/dpct/helper.hpp,2081,18,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        return q.memcpy(to_ptr, from_ptr, size, dep_events);",8ed9a6523ce1194f6a3253a992145afdc9361da68dd13bfae125e1d10ea4e8c3,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/dpct/helper.hpp,2755,22,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                std::memcpy(_host_ptr, init_list.begin(), init_list.size() * sizeof(T));",aee308b9c388570df9cf622e2dc5f481884e5dbb169c2a5e85bdc0042df3df4d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/dpct/helper.hpp,2770,26,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                    std::memcpy(tmp_data, sub_list.begin(),",ee4383e99a0a8f4bb8d5b01aab0b47af28a7bc77de0a80d119c39e2272869b0d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/element_wise.cpp,887,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&negative_slope, dst->op_params, sizeof(float));",333d269d216cce02eae4a4526913fa678c60c50c944c522e3a4313aad2870d02,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/element_wise.cpp,933,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&min_val, dst->op_params, sizeof(float));",da83ccce2ed960b34a596280caf36c329e8e8a2aaffcd82203068f4541f317f9,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/element_wise.cpp,934,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&max_val, (float *) dst->op_params + 1, sizeof(float));",788f4e2768e3418a532c04713a7e69665b554091b26773eb6188829895b05d5d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,262,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char error_buf[256];,691f1923e861b2152114667da22b80ea0a3d5ddc27c3fcc8fa0dd89469f29b74,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,398,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(host_buf, data, size);",0c4708452f14d28b6ad7683a9517f4f52cda2e560cd56afe347ca1c5cb296700,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,399,42,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    SYCL_CHECK(CHECK_TRY_ERROR((*stream).memcpy((char *) tensor->data + offset, host_buf, size).wait()));",14b236578223023cd045d86bf90516a496f955271444f764d2dc3eae93ec8bfc,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,402,42,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    SYCL_CHECK(CHECK_TRY_ERROR((*stream).memcpy((char *) tensor->data + offset, data, size).wait()));",73884121fe1ea289a05d17cb78d675510aca3f766ba3531c5200dd8fa6830dd4,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,424,16,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        stream.memcpy(data, (const char *)tensor->data + offset, size)",d6d07ec026f8ad02a1c2fede158385aa8e5dd07cbab99ab7ee475ff656464b5f,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,436,11,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    q_src.memcpy(host_buf, (const char *)ptr_src, size).wait();",f7d9fc126238a5f30ecbdb80faeaecd1a8298bc360c5107e657067e9c23d3496,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,437,11,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    q_dst.memcpy((char *)ptr_dst, host_buf, size).wait();",a09cf5a7260d2eed960c2611467f3d51dbf7eec60737f897b7e0ee5cb42d5ea8,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,485,46,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,        SYCL_CHECK(CHECK_TRY_ERROR((*stream).memcpy(,dfe65413d8fe0b60431ff7365c5344f830720e77f887717c0472ca67a97b9490,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,851,13,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,            char err_buf[1024];,3888030e00ae485e0b5e504f88f52374bda0ca4c372ae2b27b8b3df9d40fd6d0,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,935,18,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                .memcpy(extra->data_device[i], buf_host, original_size)",ee5421388ad07a70d303141ac3aab57b84bd3bf7db8c8c84fca3b9b2a74bfb21,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,991,18,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                .memcpy(buf_host, extra->data_device[i], original_size)",072d6f624397897b5f2059da4d30b63113b886ab7dd086130919917e81b38d7b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,2189,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&scale, (float *) dst->op_params + 0, sizeof(float));",0de6e2b61f9c2dd931ae94cdd27bcbf51aa5feec5f255a19c257b8a5a3ff4252,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,2190,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&bias,  (float *) dst->op_params + 1, sizeof(float));",09417f363cff47e6446d52333031624851535e805dad1f062a118da056c39d05,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,2446,55,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                                                    ->memcpy(src1_ddq_i, src1_ddq_i_source,",d75d4cfcb221643672869d184d098d097b8de1c8ff52c801a889a46a6c26d8df,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,2512,37,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                            stream->memcpy(dhf_dst_i, dst_dd_i,",e25f2b2d8cd99ebda84fcccd89af565fdd85d18b826c23824547e15536130e39,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,2988,35,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        CHECK_TRY_ERROR((*stream).memcpy(tmp_buf, data_device, size)",ceef8a636bdb63277eaf6a1e94ebb14c40087ff83488dd8841bd863d65320fdb,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,3019,42,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    SYCL_CHECK(CHECK_TRY_ERROR((*stream).memcpy(tmp_buf, data_device, size).wait()));",2a8df31ebd7b077e6018ef7c5a10ab51808422a5e425b0ec9618152127b27ef0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,3050,42,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    SYCL_CHECK(CHECK_TRY_ERROR((*stream).memcpy(tmp_buf, data_device, size).wait()));",2a8df31ebd7b077e6018ef7c5a10ab51808422a5e425b0ec9618152127b27ef0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,3327,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        stream->memcpy(ids_host.data(), ids_dev, ggml_nbytes(ids))));",546c4862f36823493d998f0eb690913ed41d9d825c7c72d16172eb3fc3d92e9d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,3853,19,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        (stream)->memcpy((char *)tensor->data + offset, data, size)));",3ecc2549977186d8370300ee763c94b95d227ee634b6d5fb66d8c2b7eeeca6cd,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,3873,42,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,    SYCL_CHECK(CHECK_TRY_ERROR((stream)->memcpy(,47e17326a7400862d000102a083f52dcd4fcdf84f6ac2aadf6abf6581b82b7a0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/ggml-sycl.cpp,3899,46,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,        SYCL_CHECK(CHECK_TRY_ERROR((stream)->memcpy(,47e17326a7400862d000102a083f52dcd4fcdf84f6ac2aadf6abf6581b82b7a0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/gla.cpp,97,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&scale, dst->op_params, sizeof(float));",260e56deea5b3fe90415a7b544e627dc78ce730f2497df675b44e4d452786dd0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/norm.cpp,429,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, dst->op_params, sizeof(float));",67d1dcfaab93c7d3db5d61cc3421ea72b1cf69937f5149cf665bab2888facbad,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/norm.cpp,453,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, dst->op_params + 1, sizeof(float));",d2da7d1499b69146f2c6c4a55ccd4b9d80794f2042855d211b9d62890d05a152,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/norm.cpp,472,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, dst->op_params, sizeof(float));",67d1dcfaab93c7d3db5d61cc3421ea72b1cf69937f5149cf665bab2888facbad,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/norm.cpp,497,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, dst->op_params, sizeof(float));",67d1dcfaab93c7d3db5d61cc3421ea72b1cf69937f5149cf665bab2888facbad,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/rope.cpp,374,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&freq_base,   (int32_t *) dst->op_params +  5, sizeof(float));",da59b27e119ace3916db1ca45730dcad4511767e0f0c0b5dc4106101bc8fde60,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/rope.cpp,375,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&freq_scale,  (int32_t *) dst->op_params +  6, sizeof(float));",0011a16f7f018110b2594dd3a7fb63ddf044ca048804765d80c46d171dbc2537,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/rope.cpp,376,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&ext_factor,  (int32_t *) dst->op_params +  7, sizeof(float));",3cd25261f2b7ff40aa3ed89f0744d42641dc93a8c62b9e31a83237a38dd1e50e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/rope.cpp,377,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&attn_factor, (int32_t *) dst->op_params +  8, sizeof(float));",2bd63996bf3ba47baca25e957f490e18933e9fe7a2315cacec608ad7b1ea1874,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/rope.cpp,378,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&beta_fast,   (int32_t *) dst->op_params +  9, sizeof(float));",dd400931e67d5ffb6294bff6b0bd22c7e882db5826f6503ce1ef96b9105f8eff,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/rope.cpp,379,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&beta_slow,   (int32_t *) dst->op_params + 10, sizeof(float));",4b857c4bd4e0be4313eb4f295814bb891d49d9476b2dec13f2dd090150bb9b27,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/rope.cpp,380,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&sections.v,  (int32_t *) dst->op_params + 11, sizeof(int)*4);",432bd53e9bd97f3e5276aced17bd385d1c0e31bea7b3015d830dd4d08fc6ea3a,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/softmax.cpp,241,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&scale, dst->op_params + 0, sizeof(float));",7c3544d5eb08aa038012924feea56c59ac0130660faf83d1c68163da7d9936d6,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/softmax.cpp,242,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&max_bias, dst->op_params + 1, sizeof(float));",52911b1c69f203a924096558cf3ca0f18329c1ac846e4284e27f89f9e69e5e1f,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4791,49,2,2,integer,atoi,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,    vk_skip_checks = (skip_checks == NULL ? 0 : atoi(skip_checks));,4aed62f64f2b9e2ca0892aab0223e78f148457dae06bb4753ee5f4c0753bd70e,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4793,53,2,2,integer,atoi,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,    vk_output_tensor = (output_tensor == NULL ? 0 : atoi(output_tensor));,fabdb8c83baf95cdbf1558204e3f5f72a51a51650017db080be5a7e33334e325,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,5309,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(dst, src, size);",bf1739c0268893b60cc4e9586cd844b37784112abdc531cf9a6d0d85199710b5,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,5504,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy((uint8_t *)dst->ptr + offset + i * width, (const uint8_t *) src + i * spitch, width);",0fd66c0f4223c8b32a8126e16e383325d682e393718cac891f2d2f801bde14f9,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,5515,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(cpy.dst, cpy.src, cpy.n);",f08351278b30ffbf58c15a2682e795f5b6cb65fdd953f055690ba5792be9894b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,5600,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(dst, (uint8_t *) src->ptr + offset, size);",2acf4f8ab1267a1cba13cb0e1100a9a895d4547a4a846777cde3d55b3c52b483,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,5615,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(cpy.dst, cpy.src, cpy.n);",f08351278b30ffbf58c15a2682e795f5b6cb65fdd953f055690ba5792be9894b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,5652,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(dst->device->sync_staging->ptr, src->device->sync_staging->ptr, size);",183a9c5ed586654004bc77028dd78cc08543c8f70b2b06f71cf7e3c4d2d5baf0,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,7516,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&scale,         (const float *) dst->op_params + 0, sizeof(float));",b0484457e3987b2011f427a21835ec6a6626b0b813a5325535cf26605bf61ac5,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,7517,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&max_bias,      (const float *) dst->op_params + 1, sizeof(float));",35e58b6f10357ba68b8b480a7bc9181965ab96218de897b7dace616e59783479,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,7518,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&logit_softcap, (const float *) dst->op_params + 2, sizeof(float));",0deabc7bdc97483f2fa1293cd4fdc3f990c81fa4a362c7beef7071d04153da14,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,9228,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&p.param1, &s01_packed, sizeof(float));",867cc56c172058d7aa6dc45822ff1a9727df50f08bc33cc33a7f80af03bddaca,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,9229,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&p.param2, &s23_packed, sizeof(float));",3d36d51fa79155be03b1de129d1de5afb42432274930c16b81952a4eecb8a62b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,9442,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(sections, (int32_t *) dst->op_params + 11, sizeof(int)*4);",5405ccbf7236f80322133d8d01980bedf95919d0c597f3b7d77ad8cdf5dd0e41,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,10170,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(to, from, sizeof(float) * ne);",028da3c34fdfd3d1e544d7ade2ec0a89153a4440a1f0767269b4ec7383df4963,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,11464,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(cpy.dst, cpy.src, cpy.n);",f08351278b30ffbf58c15a2682e795f5b6cb65fdd953f055690ba5792be9894b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,11489,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(cpy.dst, cpy.src, cpy.n);",f08351278b30ffbf58c15a2682e795f5b6cb65fdd953f055690ba5792be9894b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,11919,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(cpy.dst, cpy.src, cpy.n);",f08351278b30ffbf58c15a2682e795f5b6cb65fdd953f055690ba5792be9894b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,11926,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(cpy.dst, cpy.src, cpy.n);",f08351278b30ffbf58c15a2682e795f5b6cb65fdd953f055690ba5792be9894b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,12468,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char pci_bus_id[16] = {};,db6e6014876dbbec5388fa1384d754bb7037bfba84b0cff75283b6fbcbb016f7,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,12959,17,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,                char desc[256];,a6420236b56bf431894cee5cfd234b25171c91cad2261dfb6bc73dbac5fbd2cb,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,13220,11,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,"    const char * srci_name[6] = {""src0"", ""src1"", ""src2"", ""src3"", ""src4"", ""src5""};",58095d3c8084f701a6d867f0688accc6e01e1b634bcb28f5c51aa74b44180b7f,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,13247,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(srci_clone->data, srci->data, srci_size);",5958f0f4d87531fc9b4e78d8f111f8f262c1a6aaf7ea5a34a27662d552b7b76d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,13248,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(srci_clone->nb, srci->nb, sizeof(size_t) * GGML_MAX_DIMS);",daf9f980df7a96c0d0370ea877814d781c0c2fa25788301349e3ec5d7cd96282,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,13271,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(srci_clone->nb, srci->nb, sizeof(size_t) * GGML_MAX_DIMS);",daf9f980df7a96c0d0370ea877814d781c0c2fa25788301349e3ec5d7cd96282,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,13549,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(comp_result, tensor_clone->data, comp_size);",618fe4c2806622d0cab66e56e4331435e4013e68b8c55301ce2d6907ab6bc5cc,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,13550,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(comp_nb, tensor_clone->nb, sizeof(size_t) * GGML_MAX_DIMS);",38979a3214bda58b5b38d20b5a4e0b987623d32798f60ef8d3c74eeccc97211b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/vulkan-shaders/vulkan-shaders-gen.cpp,840,17,2,2,misc,fopen,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"    FILE* hdr = fopen(target_hpp.c_str(), ""w"");",cac17ecbb75a2de2c8563daa4bbf52f3e54b196756fe0840963f6acdb01c79aa,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/src/ggml-vulkan/vulkan-shaders/vulkan-shaders-gen.cpp,841,17,2,2,misc,fopen,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"    FILE* src = fopen(target_cpp.c_str(), ""w"");",b50b8b362c5c158fd67cbc3f86f002796ca122afa2244a2bad7653976f7ee315,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/src/ggml-vulkan/vulkan-shaders/vulkan-shaders-gen.cpp,856,21,2,2,misc,fopen,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"        FILE* spv = fopen(path.c_str(), ""rb"");",f42d37a39492bed6835ddbc313094311a1238d95f7167f8a9d61964705ec3bd2,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/src/ggml-webgpu/ggml-webgpu.cpp,697,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(&eps, dst->op_params, sizeof(float));",67d1dcfaab93c7d3db5d61cc3421ea72b1cf69937f5149cf665bab2888facbad,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-webgpu/ggml-webgpu.cpp,945,10,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    std::memcpy(data, mapped_range, size);",3a16f6b25f746bb583837e9c7516eb71b6e2de534fd2280b17ca4d96c7657aea,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-zdnn/common.hpp,30,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[128];,46132eacf231df987674de8924ebd73264789288957c93f364cfd2ec4f2b1218,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-zdnn/common.hpp,47,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char name[GGML_MAX_NAME];,1a55484bae218b06b850288868d209f3aaae0ccf755fc7d2ab9950128dddd776,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml-zdnn/ggml-zdnn.cpp,281,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy((char *)tensor->data + offset, data, size);",f47ea8438f74d72418a2ec0149037691f4080c0af7fac7f1aba99f56e3b8b1f9,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-zdnn/ggml-zdnn.cpp,294,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(data, (const char *)tensor->data + offset, size);",5f4f83127881f1082c15919f9653d570126742581f0094ff3d74a4dd8397b0ae,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,139,16,2,2,misc,fopen,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"    FILE * f = fopen(""/proc/self/status"", ""r"");",d4ed4984b238b052ca427787b4e14b44640e56a8d265943c73e811a60a44fe81,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/src/ggml.c,166,9,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,        char attach[32];,a3a249cce5a66bb94bd76af39f21942330c61e4718b94c0171bf2ec7c3abf3b4,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml.c,217,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char message[2048];,9ce4819eb12ebcfc569c5ba1f9c625e930be47bcf659d7d43234d93680753ad4,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml.c,254,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char buffer[128];,bbb368e12028053051f7e7a8cae6a0668c5084d93a02908e0f475627036496c7,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml.c,540,16,2,2,buffer,MultiByteToWideChar,"Requires maximum length in CHARACTERS, not bytes (CWE-120).",,,CWE-120,"    int wlen = MultiByteToWideChar(CP_UTF8, 0, mbs, -1, NULL, 0);",faf31c69ddedd5c3b8457e6625219b9ae97ee6e7bfdafc9caf637face3e326e3,2.0.19,FF1023,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,547,12,2,2,buffer,MultiByteToWideChar,"Requires maximum length in CHARACTERS, not bytes (CWE-120).",,,CWE-120,"    wlen = MultiByteToWideChar(CP_UTF8, 0, mbs, -1, wbuf, wlen);",057ffd01e0b0c3a8f80a345c1a2300f7747996268d6dfb7c6d308e3fc1ee2cea,2.0.19,FF1023,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,581,12,2,2,misc,fopen,"Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents? (CWE-362).",,,CWE-362,"    return fopen(fname, mode);",60377acb7100cb0c3420429e006bfd5f9eca090612e293ca48babece70f731c7,2.0.19,FF1040,https://cwe.mitre.org/data/definitions/362.html
./ggml/src/ggml.c,895,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char padding[4];,50660a4f45b64d02d4ccb1b9830e455800a8be898dcf0c064610e4a7df29804d,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml.c,920,14,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,static const char * GGML_OP_NAME[GGML_OP_COUNT] = {,75b154cbf830d5bc7d95d92cdf5f9bb9dafe37be10195a3c2dbd7fb80c878aa8,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml.c,1024,14,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,static const char * GGML_OP_SYMBOL[GGML_OP_COUNT] = {,7618d8f5197d060e218b2ad95dd78f9f28ba6114cdfb7e9d2f86ebbfd5f607f4,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml.c,1130,14,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,static const char * GGML_UNARY_OP_NAME[GGML_UNARY_OP_COUNT] = {,55d44e2f2597a8c741191591b2971098f49c2319a869914220e079d45a6b2e4e,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml.c,1151,14,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,static const char * GGML_GLU_OP_NAME[GGML_GLU_OP_COUNT] = {,ae6cc7c274821393a42a34300cf049ce86e012179cf65775f32d49796c62f273,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml.c,3863,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy((float *) result->op_params + 0, &scale,    sizeof(float));",261be5e3e7e64d428bcdf0103b39a162daf16f4f60b606fce44c070835f3cc8b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,3864,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy((float *) result->op_params + 1, &max_bias, sizeof(float));",f0e4947e332bca58f02d88c4c7fd7771d62391aa799c67b3316d76b48d916e0a,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,3925,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(params +  5, &freq_base,    sizeof(float));",fee75d4e9910ac2d8bb01c8137d3268124b7dafe4a0e95cccd4e423bab5b8ae8,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,3926,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(params +  6, &freq_scale,   sizeof(float));",0cff5b0c1daeab19e39ff4b570f3c0af4eee30f1133d0878b8fb41001f1d2efc,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,3927,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(params +  7, &ext_factor,   sizeof(float));",4303a6f832208d5d315dd6a8a5f312a5531ba13e6d883022a86b4bc48542b376,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,3928,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(params +  8, &attn_factor,  sizeof(float));",66dbde155603cb43253c36fa18d01c585b0a17206879d8a4eb5c2d0435a157a4,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,3929,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(params +  9, &beta_fast,    sizeof(float));",75565f014f799b4ba8812e7f1d55ec0bdd497e619e2ea2cfff7abb2145ee18da,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,3930,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(params + 10, &beta_slow,    sizeof(float));",cab9e303853cacab373c188534788b2dafa0d6f25ea0a20c40591f927cf2744c,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,3932,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(params + 11, sections,  sizeof(int32_t) * GGML_MROPE_SECTIONS);",a9691af5647c29b822c1e18545de7cabb91dfb84ccf96bfd82f77ee8f9c03357,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,6077,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(&eps, tensor->op_params, sizeof(float));",7853fa39000d108f51bc69276c340ac52ca27401bc83b4da7686b3019bc9ea1f,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,6137,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(&s, tensor->op_params, sizeof(float));",51c2ab565b036cc5de602d0a9a489383a31c91c558d3c40fa48a9632f59f7f97,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,6270,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(&scale,    (const float *) tensor->op_params + 0, sizeof(float));",bee69628f9152286b3db8573d56377b0369ded379d223fa013a271b5e6eb571a,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,6271,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(&max_bias, (const float *) tensor->op_params + 1, sizeof(float));",98616c1864adf27c732a7c48fac7d2b3202e940b3fa7d29139e18fa304a1935b,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,6287,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(&freq_base,   (const float *) tensor->op_params +  5, sizeof(float));",26c2cce7f066f47fd7bdaeb0248f309cd312be5dfa390478f390b201bb4c2462,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,6288,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(&freq_scale,  (const float *) tensor->op_params +  6, sizeof(float));",00002bfb98b055c90ed643ccf62e9cb5f17a286cdc1b6e98d94836ca6126a31f,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,6289,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(&ext_factor,  (const float *) tensor->op_params +  7, sizeof(float));",601cce30e2eafedf691c777aadd7469f8af074f066259938cf60f41be6350326,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,6290,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(&attn_factor, (const float *) tensor->op_params +  8, sizeof(float));",c5e95e75f3cce5f35273007b2461d2bb8fe7714cd64d4da5d6e65beb95f2f9cf,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,6291,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(&beta_fast,   (const float *) tensor->op_params +  9, sizeof(float));",8c28b7132db084bd7ddac2fb4aa47c6e3935a951264fce79cf2a7ebb5ef8caa2,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,6292,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy(&beta_slow,   (const float *) tensor->op_params + 10, sizeof(float));",cd3bffcd7f078baeb4fbb3f6de7dc1ed9bf79b0fba6a6a6f8e67cfa9f3c9bf86,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,6922,5,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,    char color[16];,17f38c73744a447dfc1a6195dae604fc933008c341d70c3d2c11b63b8cbb0961,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml.c,7022,17,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,                char label[16];,5b03cbc009b4fb2224dd5cb79f8ef14af1c5f4e99864318b13b00f0affcbd158,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml.c,7034,17,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,                char label[16];,5b03cbc009b4fb2224dd5cb79f8ef14af1c5f4e99864318b13b00f0affcbd158,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/src/ggml.c,7171,17,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"                memcpy((uint8_t *)dst + start * elemsize, src + start, result);",7d357ca7444f5a07968826ab403c8c4548165b8884fb866a2f23f98366b32332,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,134,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(data.data(), &value, sizeof(T));",3430743918e00ff093dd5dfd2337158739ae9d808c5db66a94722ac271ad0e9e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,144,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(data.data() + i*sizeof(T), &tmp, sizeof(T));",7433108915642f992df0cbb0a93cd4e1dc98773f40de63c17c2dba13121d99ea,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,1048,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(tmp.data(), data, nbytes);",e6bd0871ef1fa99138b25de76f98c53e67e7bade65d929ba10310bcc03c097d9,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,1285,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(buf.data() + offset, info.t.data, nbytes);",989fff76bbe6fc196f1abd4a86ebcff9d6caf11018e6fae2904da4f8ed60b247,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,1357,5,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"    memcpy(data, buf.data(), buf.size());",a2b6efd70ff4c73e3d1e8a0c4d4d29619e80af7a6019621a6f995912bfa8ed69,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-backend-ops.cpp,389,9,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,        char   buf[32];,6a8ff2d4c585c0ff70bbac1ada34b432422ec4ae306653ae9b828e289a9ccf41,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/tests/test-backend-ops.cpp,417,9,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,        char   buf[32];,6a8ff2d4c585c0ff70bbac1ada34b432422ec4ae306653ae9b828e289a9ccf41,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/tests/test-backend-ops.cpp,802,17,2,2,buffer,char,"Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).","Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.",,CWE-119!/CWE-120,                char buf[256];,86753089edd8e96675f0102bc52bd39c8f2c94e4f63e4a6e6052dfa82d40f6a3,2.0.19,FF1013,https://cwe.mitre.org/data/definitions/119.html
./ggml/tests/test-conv-transpose-1d.cpp,161,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.a_0->data, adata_0, ggml_nbytes(model.a_0));",2f874e79ab708bd794d022e48491c349c708c6f6972aec8e5ea3170f4c17de6e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv-transpose-1d.cpp,172,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.a_1->data, adata_1, ggml_nbytes(model.a_1));",c0e8fc0a8f217cff263154ad585ffa30798f01111ec3da06e4884f8183ddf2d9,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv-transpose-1d.cpp,182,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.a_2->data, adata_2, ggml_nbytes(model.a_2));",dff3611bf713258eda45ff620608a9f13a37a0536b6f97d020e522652aa9aa66,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv-transpose-1d.cpp,192,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.a_3->data, data, ggml_nbytes(model.a_3));",c2e3de4436b2149f80799699f64241db2c23c000b753c6ee16fb56ed62c73248,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv-transpose-1d.cpp,203,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.a_4->data, data, ggml_nbytes(model.a_4));",7adcd338a9c78c7d88b0511c7ffb45835c4f6edc2ceb6e2f8587bc044ada3dca,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv-transpose-1d.cpp,218,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.b_0->data, bdata_0, ggml_nbytes(model.b_0));",42a37f3b452a51a27d1ad0c6febba334a8e3d3b5b9c51b786a5eab699bcf3072,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv-transpose-1d.cpp,231,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.b_1->data, bdata_1, ggml_nbytes(model.b_1));",5dac8a1e9d1453fe28c0ba10cbf419595aa6be3277ddc97d712df72c1a93677c,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv-transpose-1d.cpp,244,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.b_2->data, bdata_2, ggml_nbytes(model.b_2));",7c3c878a4079949d1e0b95deff20dccabfd0028f669289cac1d405acc7fce767,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv-transpose-1d.cpp,257,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.b_3->data, data, ggml_nbytes(model.b_3));",01e752a18a2de305bff0d5363c8b5fd5fb1d0ef77b157135e8ca5a1354743fa2,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv-transpose-1d.cpp,271,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.b_4->data, data, ggml_nbytes(model.b_4));",09b9a42f317df2d2fb40d158420fe2376b225b766c8dea579036783185d13448,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv-transpose.c,98,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t->data, buf_f32, ggml_nbytes(t));",5930aef1f8482c61a37a5ff239d4ed93662151fe39997322f72d600f9b25c438,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv-transpose.c,101,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(k->data, buf_f16, ggml_nbytes(k));",ea485acbf09c54b13e2c8e70821f0a03d2040c9458dad2bb5f9cd1669c8a179e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv-transpose.c,205,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t->data, buf_f32, ggml_nbytes(t));",5930aef1f8482c61a37a5ff239d4ed93662151fe39997322f72d600f9b25c438,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv-transpose.c,208,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(k->data, buf_f16, ggml_nbytes(k));",ea485acbf09c54b13e2c8e70821f0a03d2040c9458dad2bb5f9cd1669c8a179e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv1d-dw-c1.cpp,119,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.weight->data, h_weight_data.data(), ggml_nbytes(model.weight));",47f779179c5cf75a488ea87817a7b63334797dc34326c4479c8b8e50cbe23012,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv1d-dw-c1.cpp,132,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.input->data, input_data, ggml_nbytes(model.input));",4a1d807569aec68b4d92ff6d253ece3fc481f0bf4090c18f735061d558953e87,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv1d-dw-c2.cpp,119,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.weight->data, h_weight_data.data(), ggml_nbytes(model.weight));",47f779179c5cf75a488ea87817a7b63334797dc34326c4479c8b8e50cbe23012,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv1d-dw-c2.cpp,132,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.input->data, input_data, ggml_nbytes(model.input));",4a1d807569aec68b4d92ff6d253ece3fc481f0bf4090c18f735061d558953e87,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv1d.cpp,121,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.a->data, hadata.data(), ggml_nbytes(model.a));",0111d382934c5ca251dd33da9b21711a6c4e737e6e3c6e9b8fa61772ead1ab4d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv1d.cpp,134,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.b->data, bdata.data(), ggml_nbytes(model.b));",4869a1200a501541cfbb97f3fe9635d76c025eee713ad39ae46f2af9ee5c1e32,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv2d.cpp,121,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.a->data, hadata.data(), ggml_nbytes(model.a));",0111d382934c5ca251dd33da9b21711a6c4e737e6e3c6e9b8fa61772ead1ab4d,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-conv2d.cpp,134,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(model.b->data, bdata.data(), ggml_nbytes(model.b));",4869a1200a501541cfbb97f3fe9635d76c025eee713ad39ae46f2af9ee5c1e32,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-customop.c,189,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t->data, buf1_f32, ggml_nbytes(t));",8009d567d23e8e0514d2ec11163a9e3c212c5973066bb12922de5c7f212efdea,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-customop.c,214,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t1->data, buf1_f32, ggml_nbytes(t1));",798887a9d8a457fa8efb68a3eb3d6f4ee5b726603f9eabf334826ed2e1ccb096,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-customop.c,215,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t2->data, buf2_f32, ggml_nbytes(t2));",f92c866d213ace92a96d6587a7c63a47c6271e0430f069790798ebcb39112245,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-customop.c,243,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t1->data, buf1_f32, ggml_nbytes(t1));",798887a9d8a457fa8efb68a3eb3d6f4ee5b726603f9eabf334826ed2e1ccb096,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-customop.c,244,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t2->data, buf2_f32, ggml_nbytes(t2));",f92c866d213ace92a96d6587a7c63a47c6271e0430f069790798ebcb39112245,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-customop.c,245,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t3->data, buf3_f32, ggml_nbytes(t3));",5896896886d734dfeabedb928e5dbf20d14a2ae27f56d1535a36abb0256a02af,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-customop.c,273,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t1->data, buf1_f32, ggml_nbytes(t1));",798887a9d8a457fa8efb68a3eb3d6f4ee5b726603f9eabf334826ed2e1ccb096,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-customop.c,274,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t2->data, buf2_f32, ggml_nbytes(t2));",f92c866d213ace92a96d6587a7c63a47c6271e0430f069790798ebcb39112245,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-customop.c,275,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t3->data, buf3_f32, ggml_nbytes(t3));",5896896886d734dfeabedb928e5dbf20d14a2ae27f56d1535a36abb0256a02af,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-customop.c,276,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t4->data, buf1_f32, ggml_nbytes(t4));",eb648914360fc7bcbb7010d767ed0ecc418c93e05c1a8c1461138ee86b775a83,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-customop.c,277,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t5->data, buf2_f32, ggml_nbytes(t5));",dcee679c7f782bed64666d6596dff34ce1dbdfd94de739eeb4612755bb0bd6ae,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-opt.cpp,18,71,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"static bool almost_equal(const double a, const double b, const double atol) {",94384d0224672f399ab01ea1148feb1e200107dde0d00e6ccf780b0eb59860d0,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,19,26,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,    return fabs(a - b) < atol;,82d87b2cd60c1267ec2f52db38b6718d7917485d17ab53c70012aff091dd0631,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,396,61,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"        subtest_ok = subtest_ok && almost_equal(loss, 33.0, atol) && almost_equal(loss_unc, sqrt(3.5), atol);",030591391d2adc6a91dce9f67ddf77691aba1eae32c9d811af5c0894f07119c0,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,396,104,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"        subtest_ok = subtest_ok && almost_equal(loss, 33.0, atol) && almost_equal(loss_unc, sqrt(3.5), atol);",030591391d2adc6a91dce9f67ddf77691aba1eae32c9d811af5c0894f07119c0,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,567,78,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"            subtest_ok = subtest_ok && almost_equal(loss, 28.0 - epoch*16.0, atol) && almost_equal(loss_unc, 0.0, atol);",f0257b80643767b40dde57415f9a9a211057cbd6fb9002dd0c3b6012d6e4fbf9,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,567,115,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"            subtest_ok = subtest_ok && almost_equal(loss, 28.0 - epoch*16.0, atol) && almost_equal(loss_unc, 0.0, atol);",f0257b80643767b40dde57415f9a9a211057cbd6fb9002dd0c3b6012d6e4fbf9,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,586,75,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"            subtest_ok = subtest_ok && almost_equal(loss, 15.0 - epoch*8, atol) && almost_equal(loss_unc, sqrt(0.5), atol);",ab2f79aad9ad0c3f7a7ff13b72913beedb8bd72bee0494b18aab2d7c5a20e8b3,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,586,118,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"            subtest_ok = subtest_ok && almost_equal(loss, 15.0 - epoch*8, atol) && almost_equal(loss_unc, sqrt(0.5), atol);",ab2f79aad9ad0c3f7a7ff13b72913beedb8bd72bee0494b18aab2d7c5a20e8b3,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,664,83,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                    subtest_ok = subtest_ok && almost_equal(grad_history[0], 1.0, atol);",c8c5c7fb4a30cac53deb240b43bd07678613dfd9ea5a4cada75bc465ba1c4f22,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,665,83,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                    subtest_ok = subtest_ok && almost_equal(grad_history[2], 3.0, atol);",806b51a3d535b1b6482e7243f3fdda76a0e50fa0dd48e6e5873cf63303ef86d8,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,666,83,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                    subtest_ok = subtest_ok && almost_equal(grad_history[4], 5.0, atol);",c1c5e5898a325cbbec63f9992aa9d3fba9c6bfdcd50222e57fcd12b6db332973,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,668,83,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                    subtest_ok = subtest_ok && almost_equal(grad_history[0], 0.0, atol);",7c542483cfeb05c17b65d442298c4e5e945349c0a6e3afbf6db49d7b119d0bf4,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,669,83,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                    subtest_ok = subtest_ok && almost_equal(grad_history[2], 0.0, atol);",cbf9332d941b90f997a883714b4a0dd26c9ae888003f73b8ce73fe5690a89001,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,670,83,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                    subtest_ok = subtest_ok && almost_equal(grad_history[4], 0.0, atol);",f884216deade90e0777e98c217b77f42e7328df77c2916067985e9e62c2e861b,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,672,79,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                subtest_ok = subtest_ok && almost_equal(grad_history[1], 2.0, atol);",f355d9066f008940cb13ad2aed3206012a43a93e05276ad2ee5fd4147a40ef3c,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,673,79,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                subtest_ok = subtest_ok && almost_equal(grad_history[3], 4.0, atol);",a46dadee72fee904086e08ded940b81afadb8b0551295ae2dc3ed6f1cfc57372,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,674,79,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                subtest_ok = subtest_ok && almost_equal(grad_history[5], 6.0, atol);",8dd54e21e0e0139de5bd2325a3d0d04802aa5c9dd640ab7b300a6e00ff55dd2f,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,677,89,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                    subtest_ok = subtest_ok && almost_equal(grad_history[0], 1.0/ndata, atol);",946f129a295ef09ad781d3fcc3a83fbf75a5213607eda1024f2dd6eed477bd0b,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,678,89,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                    subtest_ok = subtest_ok && almost_equal(grad_history[2], 3.0/ndata, atol);",25376d7ff0ebedb098b1d031b1ddad5d84eae09e3a72e20d9bbef21167f83c22,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,679,89,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                    subtest_ok = subtest_ok && almost_equal(grad_history[4], 5.0/ndata, atol);",ded3ee3385d4c7f68141f493ec03b16b1c1f47075d98737c4cfafb983c6d5641,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,681,89,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                    subtest_ok = subtest_ok && almost_equal(grad_history[0], 0.0/ndata, atol);",b02a4045cf4010c36b44ce34e1795336c33fe7d4164c0d7168ee24f20e719ade,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,682,89,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                    subtest_ok = subtest_ok && almost_equal(grad_history[2], 0.0/ndata, atol);",e0d605608b975b69458627f0f17045db2c2dc56b5de6228fe5fb4623d35b3a0f,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,683,89,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                    subtest_ok = subtest_ok && almost_equal(grad_history[4], 0.0/ndata, atol);",23dd9193e73112725551b6c746b6c1009b21edc3bc0c9226c4451b38f3db973c,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,685,85,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                subtest_ok = subtest_ok && almost_equal(grad_history[1], 2.0/ndata, atol);",cfd45402e20a48f361f492704c3feb0258df3b7fe65ff404da287e3eb40c6364,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,686,85,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                subtest_ok = subtest_ok && almost_equal(grad_history[3], 4.0/ndata, atol);",ebe840201a1eeaee80f729d66539a56000d64b759f4aeaf09cba349a1ed4b8fb,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,687,85,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                subtest_ok = subtest_ok && almost_equal(grad_history[5], 6.0/ndata, atol);",fab557d76b37517d5e8697e87b70884845e57eea8f3e47f9f57db4fb2fb69d01,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,698,78,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"            const bool subtest_ok = almost_equal(weights, (ndata/2) - epoch, atol);",e6bd6c17d79277d47834e36087de8c5df877a9202e7663f2c13dbd1bd7af732b,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,705,81,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"            bool subtest_ok = almost_equal(ndata_result, ndata/nbatch_physical, atol);",e58f6a8b17a77029acd0a195035c4589a8891ffd688883fce11d0e0d5e271d14,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,710,83,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                subtest_ok = subtest_ok && almost_equal(loss, (39.0 - epoch*6.0), atol);",58698d77b766c422565a5a4eb20fc75179236de2814fe8c36918cf7e766e443c,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-opt.cpp,712,91,2,2,integer,atol,"Unless checked, the resulting number can exceed the expected range (CWE-190).","If source untrusted, check both minimum and maximum, even if the input had no minus sign (large numbers can roll over into negative number; consider saving to an unsigned value if that is intended).",,CWE-190,"                subtest_ok = subtest_ok && almost_equal(loss, (39.0 - epoch*6.0) / ndata, atol);",53033306e9cf98c82019b4c835a27fe15dd8b6e01419188c0dd1ec4ffea4c9d5,2.0.19,FF1047,https://cwe.mitre.org/data/definitions/190.html
./ggml/tests/test-pad-reflect-1d.cpp,110,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(t->data, input_data, ggml_nbytes(t));",d8a342a9fbca788c7efbfadcef8ff0a0c8470510806e35ef2ab44436c69c9692,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-pad-reflect-1d.cpp,174,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(t->data, input_data, ggml_nbytes(t));",d8a342a9fbca788c7efbfadcef8ff0a0c8470510806e35ef2ab44436c69c9692,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-pool.c,29,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t->data, buf_f32, ggml_nbytes(t));",5930aef1f8482c61a37a5ff239d4ed93662151fe39997322f72d600f9b25c438,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-pool.c,57,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t->data, buf_f16, ggml_nbytes(t));",bdf2618ddb401863f9c0b69b4235ff9c7b6c7fc35485f09e90f2f1bfcbd9e52e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-pool.c,85,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t->data, buf_f32, ggml_nbytes(t));",5930aef1f8482c61a37a5ff239d4ed93662151fe39997322f72d600f9b25c438,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-pool.c,112,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t->data, buf_f16, ggml_nbytes(t));",bdf2618ddb401863f9c0b69b4235ff9c7b6c7fc35485f09e90f2f1bfcbd9e52e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-pool.c,139,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t->data, buf_f32, ggml_nbytes(t));",5930aef1f8482c61a37a5ff239d4ed93662151fe39997322f72d600f9b25c438,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-pool.c,174,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t->data, buf_f16, ggml_nbytes(t));",bdf2618ddb401863f9c0b69b4235ff9c7b6c7fc35485f09e90f2f1bfcbd9e52e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-pool.c,209,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t->data, buf_f32, ggml_nbytes(t));",5930aef1f8482c61a37a5ff239d4ed93662151fe39997322f72d600f9b25c438,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-pool.c,243,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t->data, buf_f16, ggml_nbytes(t));",bdf2618ddb401863f9c0b69b4235ff9c7b6c7fc35485f09e90f2f1bfcbd9e52e,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-rel-pos.c,51,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t_d, buf_f16, ggml_nbytes(t));",4a6f0f7965c83e6031f39df91ee32ea46c23c9d68706318f7facce68c139aff4,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-rel-pos.c,55,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(t_d_2, buf_f16 + 1, ggml_nbytes(t_2));",f8223fbc6bcc84143ae662b40418395f60ac9da3d0677cda565af637e03df74a,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-timestep_embedding.cpp,78,9,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"        memcpy(timesteps->data, ts.data(), ggml_nbytes(timesteps));",69365654adc94d9d83f46467bff223b294b3852a5a23e7608b40265543988295,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/tests/test-timestep_embedding.cpp,139,13,2,2,buffer,memcpy,Does not check for buffer overflows when copying to destination (CWE-120).,Make sure destination can always hold the source data.,,CWE-120,"            memcpy(timesteps->data, ts.data(), ggml_nbytes(timesteps));",69365654adc94d9d83f46467bff223b294b3852a5a23e7608b40265543988295,2.0.19,FF1004,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/common-ggml.cpp,101,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read(reinterpret_cast<char *>(&n_dims), sizeof(n_dims));",41950541eceaf0447ae4eac8a83ca7ea1dd9bd3af3a7b4fa6691180347f381c4,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/common-ggml.cpp,102,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read(reinterpret_cast<char *>(&length), sizeof(length));",03dad9a14c676d2ffeb02f20340a23eac419a994f1c79c3e4f8024a5dce3daf1,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/common-ggml.cpp,103,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read(reinterpret_cast<char *>(&ttype),  sizeof(ttype));",1561c468be05f5af9f09185b304e2816e0c722f8159a188d9386e75cf49fbe1f,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/common-ggml.cpp,112,18,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            finp.read (reinterpret_cast<char *>(&ne[i]), sizeof(ne[i]));",4d86d7168c3e548a4a3c1b56093b55ae01d3144f2a432f68e6f1cea3e38d2ede,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/common-ggml.cpp,117,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read (&name[0], length);",0f7bbb79d0a40506988839b9ded4dbb6a6ef23487d78e5ae68162cb0907cf97c,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/common-ggml.cpp,150,22,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","                finp.read(reinterpret_cast<char *>(data_f16.data()), nelements * sizeof(ggml_fp16_t));",90696db9f91eab46efbea88631ecb096dd35108a4a09da6fd1cdac1bad7807c3,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/common-ggml.cpp,157,22,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","                finp.read(reinterpret_cast<char *>(data_f32.data()), nelements * sizeof(float));",29eb0e2037134f9f329e26cf89180ca23c16cd548fcb479d9cfdb6a6ec1a5e60,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/common-ggml.cpp,165,18,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            finp.read(reinterpret_cast<char *>(data_u8.data()), nelements * bpe);",095ecfee5ddf6fb973f6c200dfc66d6c6119c681b992304eda925c9c218d702d,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/common.cpp,346,68,1,1,buffer,strlen,Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).,,,CWE-126,            std::string s_tokens = line.substr(delimiterPos + std::strlen(delimeter));,99fa51795369d98febb347fb303261df17a5172c0d0d2f9d311945671f2452d5,2.0.19,FF1022,https://cwe.mitre.org/data/definitions/126.html
./ggml/examples/gpt-2/main-alloc.cpp,91,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &magic, sizeof(magic));",a3f11e2ea021deb49fd46de9b6d1281247b8a21dd275580be851ad6489ac6b16,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,102,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_vocab, sizeof(hparams.n_vocab));",d17206dba062c6519beca4df0fcc1c2b7ed3fb5d5ae063f0bc7fdb19040230db,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,103,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_ctx,   sizeof(hparams.n_ctx));",f9ac5a84a4cc3cfc2a47b8dcfd9906da8707a78d6d604a0372ae491c3bb5a872,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,104,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_embd,  sizeof(hparams.n_embd));",d81b71283890ffb93a50e35d49ac852266d5940f9dff3aa8bbd4c0705b1fedea,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,105,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_head,  sizeof(hparams.n_head));",1c84913186645bed9ec21fee5ed83f508172c93f8a8b15167162dfbd65cbf891,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,106,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_layer, sizeof(hparams.n_layer));",88f8e5ae02bd5af4999dbb6922cd3a4f92802be8b006ac9ce7433902905e35de,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,107,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.ftype,   sizeof(hparams.ftype));",ba8ea8f3f972a2ba18f9a92f2ecb3bea6d533c102e3041355df34e493f099131,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,125,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &n_vocab, sizeof(n_vocab));",4227915e1730bc68421cc9c59be60826af71ae37fc3a559e8f31c26f8c872b7e,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,138,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read((char *) &len, sizeof(len));",e28905cdcf399e9876dcc203f177018c0b98f448c2a03fd007d5124b158c28ee,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,141,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read((char *) buf.data(), len);",1ed59c4e13d272e55e88f206619c836a228975c49436fa45c80791f4e02a08ad,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,317,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&n_dims), sizeof(n_dims));",affd1994abed7c16ced90cbc775a29276c8e245ce449177f60be85ac288f17b0,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,318,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&length), sizeof(length));",52f30943577387ec93f078094c3df2b798006ce6b5f2c3e666b7931c008805af,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,319,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&ttype),  sizeof(ttype));",5e89ed4788187f6904c2c48998236895a6086403f2b249d406f840f1bfa33c2d,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,328,21,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","                fin.read(reinterpret_cast<char *>(&ne[i]), sizeof(ne[i]));",e778e3df8c7870e04af2fc2d353e35edcc3510a630a0decaf232b97b3493f416,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,333,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(&name[0], length);",8ef2934418f7a930fd9b4c5416bcdcccfbc76945a6f15218e5951a94e2a3c6a1,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-alloc.cpp,365,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(tensor->data), ggml_nbytes(tensor));",da7fe51d6f26cc54a45df69bf1d7eb96c78ba4761fb0ba87fb71895e41d2b222,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,115,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &magic, sizeof(magic));",a3f11e2ea021deb49fd46de9b6d1281247b8a21dd275580be851ad6489ac6b16,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,126,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_vocab, sizeof(hparams.n_vocab));",d17206dba062c6519beca4df0fcc1c2b7ed3fb5d5ae063f0bc7fdb19040230db,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,127,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_ctx,   sizeof(hparams.n_ctx));",f9ac5a84a4cc3cfc2a47b8dcfd9906da8707a78d6d604a0372ae491c3bb5a872,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,128,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_embd,  sizeof(hparams.n_embd));",d81b71283890ffb93a50e35d49ac852266d5940f9dff3aa8bbd4c0705b1fedea,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,129,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_head,  sizeof(hparams.n_head));",1c84913186645bed9ec21fee5ed83f508172c93f8a8b15167162dfbd65cbf891,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,130,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_layer, sizeof(hparams.n_layer));",88f8e5ae02bd5af4999dbb6922cd3a4f92802be8b006ac9ce7433902905e35de,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,131,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.ftype,   sizeof(hparams.ftype));",ba8ea8f3f972a2ba18f9a92f2ecb3bea6d533c102e3041355df34e493f099131,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,149,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &n_vocab, sizeof(n_vocab));",4227915e1730bc68421cc9c59be60826af71ae37fc3a559e8f31c26f8c872b7e,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,162,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read((char *) &len, sizeof(len));",e28905cdcf399e9876dcc203f177018c0b98f448c2a03fd007d5124b158c28ee,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,165,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read((char *) buf.data(), len);",1ed59c4e13d272e55e88f206619c836a228975c49436fa45c80791f4e02a08ad,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,365,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&n_dims), sizeof(n_dims));",affd1994abed7c16ced90cbc775a29276c8e245ce449177f60be85ac288f17b0,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,366,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&length), sizeof(length));",52f30943577387ec93f078094c3df2b798006ce6b5f2c3e666b7931c008805af,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,367,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&ttype),  sizeof(ttype));",5e89ed4788187f6904c2c48998236895a6086403f2b249d406f840f1bfa33c2d,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,376,21,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","                fin.read(reinterpret_cast<char *>(&ne[i]), sizeof(ne[i]));",e778e3df8c7870e04af2fc2d353e35edcc3510a630a0decaf232b97b3493f416,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,381,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(&name[0], length);",8ef2934418f7a930fd9b4c5416bcdcccfbc76945a6f15218e5951a94e2a3c6a1,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,416,21,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","                fin.read(reinterpret_cast<char *>(tensor->data), ggml_nbytes(tensor));",da7fe51d6f26cc54a45df69bf1d7eb96c78ba4761fb0ba87fb71895e41d2b222,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-backend.cpp,420,21,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","                fin.read(read_buf.data(), ggml_nbytes(tensor));",480d85812623a1bdf08072fd0c729560aece456c3f4e93bc06fb18a64c5548fa,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,162,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &magic, sizeof(magic));",a3f11e2ea021deb49fd46de9b6d1281247b8a21dd275580be851ad6489ac6b16,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,173,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_vocab, sizeof(hparams.n_vocab));",d17206dba062c6519beca4df0fcc1c2b7ed3fb5d5ae063f0bc7fdb19040230db,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,174,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_ctx,   sizeof(hparams.n_ctx));",f9ac5a84a4cc3cfc2a47b8dcfd9906da8707a78d6d604a0372ae491c3bb5a872,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,175,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_embd,  sizeof(hparams.n_embd));",d81b71283890ffb93a50e35d49ac852266d5940f9dff3aa8bbd4c0705b1fedea,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,176,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_head,  sizeof(hparams.n_head));",1c84913186645bed9ec21fee5ed83f508172c93f8a8b15167162dfbd65cbf891,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,177,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_layer, sizeof(hparams.n_layer));",88f8e5ae02bd5af4999dbb6922cd3a4f92802be8b006ac9ce7433902905e35de,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,178,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.ftype,   sizeof(hparams.ftype));",ba8ea8f3f972a2ba18f9a92f2ecb3bea6d533c102e3041355df34e493f099131,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,196,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &n_vocab, sizeof(n_vocab));",4227915e1730bc68421cc9c59be60826af71ae37fc3a559e8f31c26f8c872b7e,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,209,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read((char *) &len, sizeof(len));",e28905cdcf399e9876dcc203f177018c0b98f448c2a03fd007d5124b158c28ee,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,212,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read((char *) buf.data(), len);",1ed59c4e13d272e55e88f206619c836a228975c49436fa45c80791f4e02a08ad,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,449,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&n_dims), sizeof(n_dims));",affd1994abed7c16ced90cbc775a29276c8e245ce449177f60be85ac288f17b0,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,450,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&length), sizeof(length));",52f30943577387ec93f078094c3df2b798006ce6b5f2c3e666b7931c008805af,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,451,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&ttype),  sizeof(ttype));",5e89ed4788187f6904c2c48998236895a6086403f2b249d406f840f1bfa33c2d,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,460,21,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","                fin.read(reinterpret_cast<char *>(&ne[i]), sizeof(ne[i]));",e778e3df8c7870e04af2fc2d353e35edcc3510a630a0decaf232b97b3493f416,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,465,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(&name[0], length);",8ef2934418f7a930fd9b4c5416bcdcccfbc76945a6f15218e5951a94e2a3c6a1,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,506,21,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","                fin.read(reinterpret_cast<char *>(tensor->data), ggml_nbytes(tensor));",da7fe51d6f26cc54a45df69bf1d7eb96c78ba4761fb0ba87fb71895e41d2b222,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-batched.cpp,510,21,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","                fin.read(read_buf.data(), ggml_nbytes(tensor));",480d85812623a1bdf08072fd0c729560aece456c3f4e93bc06fb18a64c5548fa,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,88,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &magic, sizeof(magic));",a3f11e2ea021deb49fd46de9b6d1281247b8a21dd275580be851ad6489ac6b16,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,99,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_vocab, sizeof(hparams.n_vocab));",d17206dba062c6519beca4df0fcc1c2b7ed3fb5d5ae063f0bc7fdb19040230db,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,100,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_ctx,   sizeof(hparams.n_ctx));",f9ac5a84a4cc3cfc2a47b8dcfd9906da8707a78d6d604a0372ae491c3bb5a872,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,101,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_embd,  sizeof(hparams.n_embd));",d81b71283890ffb93a50e35d49ac852266d5940f9dff3aa8bbd4c0705b1fedea,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,102,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_head,  sizeof(hparams.n_head));",1c84913186645bed9ec21fee5ed83f508172c93f8a8b15167162dfbd65cbf891,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,103,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_layer, sizeof(hparams.n_layer));",88f8e5ae02bd5af4999dbb6922cd3a4f92802be8b006ac9ce7433902905e35de,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,104,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.ftype,   sizeof(hparams.ftype));",ba8ea8f3f972a2ba18f9a92f2ecb3bea6d533c102e3041355df34e493f099131,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,122,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &n_vocab, sizeof(n_vocab));",4227915e1730bc68421cc9c59be60826af71ae37fc3a559e8f31c26f8c872b7e,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,135,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read((char *) &len, sizeof(len));",e28905cdcf399e9876dcc203f177018c0b98f448c2a03fd007d5124b158c28ee,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,138,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read((char *) buf.data(), len);",1ed59c4e13d272e55e88f206619c836a228975c49436fa45c80791f4e02a08ad,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,314,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&n_dims), sizeof(n_dims));",affd1994abed7c16ced90cbc775a29276c8e245ce449177f60be85ac288f17b0,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,315,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&length), sizeof(length));",52f30943577387ec93f078094c3df2b798006ce6b5f2c3e666b7931c008805af,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,316,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&ttype),  sizeof(ttype));",5e89ed4788187f6904c2c48998236895a6086403f2b249d406f840f1bfa33c2d,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,325,21,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","                fin.read(reinterpret_cast<char *>(&ne[i]), sizeof(ne[i]));",e778e3df8c7870e04af2fc2d353e35edcc3510a630a0decaf232b97b3493f416,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,330,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(&name[0], length);",8ef2934418f7a930fd9b4c5416bcdcccfbc76945a6f15218e5951a94e2a3c6a1,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-ctx.cpp,362,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(tensor->data), ggml_nbytes(tensor));",da7fe51d6f26cc54a45df69bf1d7eb96c78ba4761fb0ba87fb71895e41d2b222,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,167,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &magic, sizeof(magic));",a3f11e2ea021deb49fd46de9b6d1281247b8a21dd275580be851ad6489ac6b16,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,178,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_vocab, sizeof(hparams.n_vocab));",d17206dba062c6519beca4df0fcc1c2b7ed3fb5d5ae063f0bc7fdb19040230db,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,179,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_ctx,   sizeof(hparams.n_ctx));",f9ac5a84a4cc3cfc2a47b8dcfd9906da8707a78d6d604a0372ae491c3bb5a872,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,180,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_embd,  sizeof(hparams.n_embd));",d81b71283890ffb93a50e35d49ac852266d5940f9dff3aa8bbd4c0705b1fedea,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,181,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_head,  sizeof(hparams.n_head));",1c84913186645bed9ec21fee5ed83f508172c93f8a8b15167162dfbd65cbf891,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,182,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_layer, sizeof(hparams.n_layer));",88f8e5ae02bd5af4999dbb6922cd3a4f92802be8b006ac9ce7433902905e35de,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,183,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.ftype,   sizeof(hparams.ftype));",ba8ea8f3f972a2ba18f9a92f2ecb3bea6d533c102e3041355df34e493f099131,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,201,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &n_vocab, sizeof(n_vocab));",4227915e1730bc68421cc9c59be60826af71ae37fc3a559e8f31c26f8c872b7e,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,214,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read((char *) &len, sizeof(len));",e28905cdcf399e9876dcc203f177018c0b98f448c2a03fd007d5124b158c28ee,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,217,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read((char *) buf.data(), len);",1ed59c4e13d272e55e88f206619c836a228975c49436fa45c80791f4e02a08ad,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,434,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&n_dims), sizeof(n_dims));",affd1994abed7c16ced90cbc775a29276c8e245ce449177f60be85ac288f17b0,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,435,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&length), sizeof(length));",52f30943577387ec93f078094c3df2b798006ce6b5f2c3e666b7931c008805af,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,436,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&ttype),  sizeof(ttype));",5e89ed4788187f6904c2c48998236895a6086403f2b249d406f840f1bfa33c2d,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,445,21,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","                fin.read(reinterpret_cast<char *>(&ne[i]), sizeof(ne[i]));",e778e3df8c7870e04af2fc2d353e35edcc3510a630a0decaf232b97b3493f416,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,450,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(&name[0], length);",8ef2934418f7a930fd9b4c5416bcdcccfbc76945a6f15218e5951a94e2a3c6a1,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,495,21,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","                fin.read(reinterpret_cast<char *>(tensor->data), ggml_nbytes(tensor));",da7fe51d6f26cc54a45df69bf1d7eb96c78ba4761fb0ba87fb71895e41d2b222,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/main-sched.cpp,499,21,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","                fin.read(read_buf.data(), ggml_nbytes(tensor));",480d85812623a1bdf08072fd0c729560aece456c3f4e93bc06fb18a64c5548fa,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/quantize.cpp,47,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read((char *) &magic, sizeof(magic));",0d1025b9c3f11d261deb0207fabffa4bb86534c266cd694ce398f8076587f260,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/quantize.cpp,60,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read((char *) &hparams.n_vocab, sizeof(hparams.n_vocab));",f87144adaaff34a3c9a3640cbd46a0c737c728356d7787eb6ccb0df41e5e539b,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/quantize.cpp,61,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read((char *) &hparams.n_ctx,   sizeof(hparams.n_ctx));",46efcfe3dc9391b4049955cbdb1e80053ea71976c8b28b7f4e2fb89c785f2921,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/quantize.cpp,62,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read((char *) &hparams.n_embd,  sizeof(hparams.n_embd));",742d5a74af2cdb82e09bf9424a6d63c4564c91c75ea26a94ca61e3e56fd72ee1,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/quantize.cpp,63,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read((char *) &hparams.n_head,  sizeof(hparams.n_head));",eba4c8aafc69c1e21e78d1b93997fcdb995bc3d71672085ee42a67b104608c28,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/quantize.cpp,64,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read((char *) &hparams.n_layer, sizeof(hparams.n_layer));",ec60b5cbd30f5bd17cf2ec4514f0e02c17a8bebb2f55d5a2b89999b00d1f67c6,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/quantize.cpp,65,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read((char *) &hparams.ftype,   sizeof(hparams.ftype));",605b6b16df6ff0ca26d958dd8e538ce4e7cf79441b71969e7d0446d313d278c4,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/quantize.cpp,91,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read ((char *) &n_vocab, sizeof(n_vocab));",ffa3203cc41d617b787f08f389050cd9451ecc5b5b1bd4014a14b1594f6d224b,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/quantize.cpp,103,18,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            finp.read ((char *) &len, sizeof(len));",1e4d26d03c296e65272ba9b309d8fd1f2cc15b1cd9bc66a61f4e87d3aab95929,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-2/quantize.cpp,107,18,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            finp.read ((char *) word.data(), len);",1ea682f0020cfad70b9073ef0c9d9cf4a8849678355619447ab3c97781c7a8e6,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,89,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &magic, sizeof(magic));",a3f11e2ea021deb49fd46de9b6d1281247b8a21dd275580be851ad6489ac6b16,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,100,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_vocab, sizeof(hparams.n_vocab));",d17206dba062c6519beca4df0fcc1c2b7ed3fb5d5ae063f0bc7fdb19040230db,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,101,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_ctx,   sizeof(hparams.n_ctx));",f9ac5a84a4cc3cfc2a47b8dcfd9906da8707a78d6d604a0372ae491c3bb5a872,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,102,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_embd,  sizeof(hparams.n_embd));",d81b71283890ffb93a50e35d49ac852266d5940f9dff3aa8bbd4c0705b1fedea,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,103,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_head,  sizeof(hparams.n_head));",1c84913186645bed9ec21fee5ed83f508172c93f8a8b15167162dfbd65cbf891,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,104,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_layer, sizeof(hparams.n_layer));",88f8e5ae02bd5af4999dbb6922cd3a4f92802be8b006ac9ce7433902905e35de,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,105,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_rot,   sizeof(hparams.n_rot));",7202e17f7a216e4a14ba5c8411d2ed1dfcb325e83ed8a00d03a3a956dedadab4,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,106,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.ftype,   sizeof(hparams.ftype));",ba8ea8f3f972a2ba18f9a92f2ecb3bea6d533c102e3041355df34e493f099131,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,125,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &n_vocab, sizeof(n_vocab));",4227915e1730bc68421cc9c59be60826af71ae37fc3a559e8f31c26f8c872b7e,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,138,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read((char *) &len, sizeof(len));",e28905cdcf399e9876dcc203f177018c0b98f448c2a03fd007d5124b158c28ee,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,141,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read((char *) buf.data(), len);",1ed59c4e13d272e55e88f206619c836a228975c49436fa45c80791f4e02a08ad,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,310,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&n_dims), sizeof(n_dims));",affd1994abed7c16ced90cbc775a29276c8e245ce449177f60be85ac288f17b0,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,311,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&length), sizeof(length));",52f30943577387ec93f078094c3df2b798006ce6b5f2c3e666b7931c008805af,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,312,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&ttype),  sizeof(ttype));",5e89ed4788187f6904c2c48998236895a6086403f2b249d406f840f1bfa33c2d,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,321,21,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","                fin.read(reinterpret_cast<char *>(&ne[i]), sizeof(ne[i]));",e778e3df8c7870e04af2fc2d353e35edcc3510a630a0decaf232b97b3493f416,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,326,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(&name[0], length);",8ef2934418f7a930fd9b4c5416bcdcccfbc76945a6f15218e5951a94e2a3c6a1,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/main.cpp,358,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(tensor->data), ggml_nbytes(tensor));",da7fe51d6f26cc54a45df69bf1d7eb96c78ba4761fb0ba87fb71895e41d2b222,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/quantize.cpp,48,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read((char *) &magic, sizeof(magic));",0d1025b9c3f11d261deb0207fabffa4bb86534c266cd694ce398f8076587f260,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/quantize.cpp,61,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read((char *) &hparams.n_vocab, sizeof(hparams.n_vocab));",f87144adaaff34a3c9a3640cbd46a0c737c728356d7787eb6ccb0df41e5e539b,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/quantize.cpp,62,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read((char *) &hparams.n_ctx,   sizeof(hparams.n_ctx));",46efcfe3dc9391b4049955cbdb1e80053ea71976c8b28b7f4e2fb89c785f2921,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/quantize.cpp,63,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read((char *) &hparams.n_embd,  sizeof(hparams.n_embd));",742d5a74af2cdb82e09bf9424a6d63c4564c91c75ea26a94ca61e3e56fd72ee1,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/quantize.cpp,64,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read((char *) &hparams.n_head,  sizeof(hparams.n_head));",eba4c8aafc69c1e21e78d1b93997fcdb995bc3d71672085ee42a67b104608c28,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/quantize.cpp,65,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read((char *) &hparams.n_layer, sizeof(hparams.n_layer));",ec60b5cbd30f5bd17cf2ec4514f0e02c17a8bebb2f55d5a2b89999b00d1f67c6,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/quantize.cpp,66,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read((char *) &hparams.n_rot,   sizeof(hparams.n_rot));",92680921fc7c1fba44e6fd66a0ced276782bf001b845ba47ae91c9cc80ee4fc7,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/quantize.cpp,67,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read((char *) &hparams.ftype,   sizeof(hparams.ftype));",605b6b16df6ff0ca26d958dd8e538ce4e7cf79441b71969e7d0446d313d278c4,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/quantize.cpp,94,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        finp.read ((char *) &n_vocab, sizeof(n_vocab));",ffa3203cc41d617b787f08f389050cd9451ecc5b5b1bd4014a14b1594f6d224b,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/quantize.cpp,106,18,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            finp.read ((char *) &len, sizeof(len));",1e4d26d03c296e65272ba9b309d8fd1f2cc15b1cd9bc66a61f4e87d3aab95929,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/gpt-j/quantize.cpp,110,18,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            finp.read ((char *) word.data(), len);",1ea682f0020cfad70b9073ef0c9d9cf4a8849678355619447ab3c97781c7a8e6,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/mnist/mnist-common.cpp,32,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) image, sizeof(image));",f4141b39524c209f96bef7573a066f001399c404602460866af3d8993a482387,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/mnist/mnist-common.cpp,75,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &label, sizeof(label));",7ad606a320fdfcdd7d584716b993980cec5d45fab9c6f191baa63f282b1a6d5c,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/mnist/mnist-common.cpp,489,9,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","    fin.read(digitPtr, MNIST_NINPUT);",3fc51838cea8d7cc957c2a1eed7d2cc351e7dc201a3e98ff255c723d17d9dc90,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/sam/sam.cpp,520,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &magic, sizeof(magic));",a3f11e2ea021deb49fd46de9b6d1281247b8a21dd275580be851ad6489ac6b16,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/sam/sam.cpp,539,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_enc_state,     sizeof(hparams.n_enc_state));",1bcb29b7411dc3c527d6d97d1e74ef6100232e2ac655fd4319c9eaaabed080fa,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/sam/sam.cpp,540,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_enc_layer,     sizeof(hparams.n_enc_layer));",5716a965d967dd215f67de91df693bbeb135cf5a70126ccb79301661e61c7fa0,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/sam/sam.cpp,541,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_enc_head,      sizeof(hparams.n_enc_head));",f04ffd941a174994f861ef15a88c0551358631fc5d599339ae64bffff9333eae,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/sam/sam.cpp,542,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_enc_out_chans, sizeof(hparams.n_enc_out_chans));",37965688f27de74d05f400598e3ebe8a4746b30a0ef9dbe81cf4c8a7e1a19415,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/sam/sam.cpp,543,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.n_pt_embd,       sizeof(hparams.n_pt_embd));",005dc80630d849c8f4cdc98066a7b09c94674f42d1a753a760b7beceb1dd2a0b,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/sam/sam.cpp,544,13,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        fin.read((char *) &hparams.ftype,           sizeof(hparams.ftype));",20678948f3bb7b672b12774dcc6fb6e2f6935d74e0d8c3f42f89c11da5b936b2,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/sam/sam.cpp,1045,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&n_dims), sizeof(n_dims));",affd1994abed7c16ced90cbc775a29276c8e245ce449177f60be85ac288f17b0,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/sam/sam.cpp,1046,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&length), sizeof(length));",52f30943577387ec93f078094c3df2b798006ce6b5f2c3e666b7931c008805af,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/sam/sam.cpp,1047,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(&ftype),  sizeof(ftype));",9faa75f59e3983440dc06fed7211fb768c187986d2c2df8e5a39122bef109b5a,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/sam/sam.cpp,1057,21,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","                fin.read(reinterpret_cast<char *>(&ne_cur), sizeof(ne_cur));",eb14ab8421b7c1bdf0e3717e8358e8d1907e4ddce0705aff43f6e7bc3845c26b,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/sam/sam.cpp,1063,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(&name[0], length);",8ef2934418f7a930fd9b4c5416bcdcccfbc76945a6f15218e5951a94e2a3c6a1,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/sam/sam.cpp,1107,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            fin.read(reinterpret_cast<char *>(tensor->data), ggml_nbytes(tensor));",da7fe51d6f26cc54a45df69bf1d7eb96c78ba4761fb0ba87fb71895e41d2b222,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,411,15,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read",a583464e215285b7e33aea2c16fc59dde97eac948d492e6b14b55e21c13d8fa6,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,857,9,1,1,buffer,fgetc,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */,ea5748f2f3bc7d0ee6b792fc61bcee861ffedacd29f88087c3b759da61ac5ed9,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,1597,19,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);",868087181212bbdfb8de4c9699ec40a3f577be02d40fdc369d4c1cca247c876d,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,1628,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",   if (s->io.read) {,0d9cdd0f4dfdca95e394cfb2838357e9fca6d944c1901e8f9941d76b88547dcb,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,1649,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",   if (s->io.read) {,0d9cdd0f4dfdca95e394cfb2838357e9fca6d944c1901e8f9941d76b88547dcb,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,1666,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",   if (s->io.read) {,0d9cdd0f4dfdca95e394cfb2838357e9fca6d944c1901e8f9941d76b88547dcb,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/examples/stb_image.h,1673,25,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);",470c5af6c98e6d6aa5021f3f35deb587c0eff85c692564e0be190942db0a338a,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-cpu/ggml-cpu.cpp,297,47,1,1,buffer,strlen,Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).,,,CWE-126,                        while (std::isspace(p[strlen(p) - 1])) {,d37c4ecb32db37a9f3489c439e9d55a4b0e5c74c092e916a3f6793ba54edbdfc,2.0.19,FF1022,https://cwe.mitre.org/data/definitions/126.html
./ggml/src/ggml-cpu/ggml-cpu.cpp,298,31,1,1,buffer,strlen,Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).,,,CWE-126,                            p[strlen(p) - 1] = '\0';,7fb308ebf3a169bde900a023acdf28d7ffd696066033ba0bdfa831eebcd3238a,2.0.19,FF1022,https://cwe.mitre.org/data/definitions/126.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,647,7,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","  ifs.read(&text[0], text.size());",a08104202f6f0a05aa052857e3f5d963117cac6c6a86e5231d58f78b4cd29da3,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-opencl/ggml-opencl.cpp,658,20,1,1,buffer,strlen,Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).,,,CWE-126,    program_size = strlen(program_buffer);,a8b5db55a6fc97613b2413aa0bb7036f1ed07b12e811c9183e34fcb81ed2e601,2.0.19,FF1022,https://cwe.mitre.org/data/definitions/126.html
./ggml/src/ggml-rpc/ggml-rpc.cpp,1126,9,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","    ifs.read((char *)data.data(), size);",67e8b54accdaa31745dddfe56108454f3fc25f0a793a3a0ac81ed62d7cff031e,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-sycl/dpct/helper.hpp,399,29,1,1,buffer,strlen,Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).,,,CWE-126,            size_t length = strlen(name);,b3cc6495ddb688dd9206db5c59945b4c7f5ce40d45c9d29bc00e290e3d7759e2,2.0.19,FF1022,https://cwe.mitre.org/data/definitions/126.html
./ggml/src/ggml-sycl/dpct/helper.hpp,1303,59,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",                (Memory == constant) ? sycl::access_mode::read,a8f016c32c366271b767d4fd9d24eac18cf17d8bc892d350f9c34ea78fb992aa,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/ggml-vulkan.cpp,4671,37,1,1,buffer,equal,Function does not check the second iterator for over-read conditions (CWE-126).,This function is often discouraged by most C++ coding standards in favor of its safer alternatives provided since C++14. Consider using a form of this function that checks the second iterator before potentially overflowing it.,,CWE-126,"                        return std::equal(std::begin(old_id.deviceUUID), std::end(old_id.deviceUUID), std::begin(new_id.deviceUUID));",b2bd0e744d0ef96b94b7c19d5b65e7ebd13cc763d82fa185f5715f96aa229534,2.0.19,FF1071,https://cwe.mitre.org/data/definitions/126.html
./ggml/src/ggml-vulkan/vulkan-shaders/vulkan-shaders-gen.cpp,156,30,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        while ((bytes_read = read(stdout_pipe[0], buffer.data(), buffer.size())) > 0) {",3a0e7d518e38b2003cf93410893e2e0d2fedfcabaed718b898bbe6c13a38e780,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/vulkan-shaders/vulkan-shaders-gen.cpp,160,30,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        while ((bytes_read = read(stderr_pipe[0], buffer.data(), buffer.size())) > 0) {",dc572d34f9d24b0f19f8bfa6eb264779514abe30243b7dd47fbdcd56554e6162,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml-vulkan/vulkan-shaders/vulkan-shaders-gen.cpp,199,17,1,1,buffer,equal,Function does not check the second iterator for over-read conditions (CWE-126).,This function is often discouraged by most C++ coding standards in favor of its safer alternatives provided since C++14. Consider using a form of this function that checks the second iterator before potentially overflowing it.,,CWE-126,"    return std::equal(prefix.begin(), prefix.end(), str.begin());",efd7404e3ec7f82d1e93fdf592e1e09013ee9310a04a1dd445e4e31f5d6914c6,2.0.19,FF1071,https://cwe.mitre.org/data/definitions/126.html
./ggml/src/ggml-vulkan/vulkan-shaders/vulkan-shaders-gen.cpp,206,17,1,1,buffer,equal,Function does not check the second iterator for over-read conditions (CWE-126).,This function is often discouraged by most C++ coding standards in favor of its safer alternatives provided since C++14. Consider using a form of this function that checks the second iterator before potentially overflowing it.,,CWE-126,"    return std::equal(suffix.rbegin(), suffix.rend(), str.rbegin());",647f073494da04a5361ca4cfff30ba7cb89942b0854601de4bcc34c99ce3ff13,2.0.19,FF1071,https://cwe.mitre.org/data/definitions/126.html
./ggml/src/ggml-zdnn/ggml-zdnn.cpp,147,9,1,1,buffer,strncpy,Easily used incorrectly; doesn't always \0-terminate or check for invalid pointers [MS-banned] (CWE-120).,,,CWE-120,"        strncpy(ctx->name, GGML_ZDNN_NAME, sizeof(ctx->name) - 1);",62824229ae609e4c6cf0e0a48540bc19834b6c59aa49e676f5f993a5daceb12b,2.0.19,FF1008,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,170,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        (void) !read(lock[0], lock, 1);",11fe70aa0f4cc4df3a202ba991b56437b4e8930df07350d036e944ab5aac94e7,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/ggml.c,566,40,1,1,buffer,strlen,Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).,,,CWE-126,        wchar_t * wmode = GGML_MALLOC((strlen(mode) + 1) * sizeof(wchar_t));,84359b007048924049bf531f47d5af3276b83f582745177a96e13c520b80f337,2.0.19,FF1022,https://cwe.mitre.org/data/definitions/126.html
./ggml/src/ggml.c,3258,9,1,1,buffer,strlen,Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).,,,CWE-126,    if (strlen(b->name) > 0) {,3499e1448ccf069d59ff15ba56b550b5ee5b1d0fd9c14fd335052ce6b67615a2,2.0.19,FF1022,https://cwe.mitre.org/data/definitions/126.html
./ggml/src/ggml.c,6441,13,1,1,buffer,strlen,Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).,,,CWE-126,        if (strlen(node->name) == 0) {,4a8f14565a48081e1025a536990c9431c5d22fac87a944b3687ad39746522e10,2.0.19,FF1022,https://cwe.mitre.org/data/definitions/126.html
./ggml/src/ggml.c,6450,13,1,1,buffer,strlen,Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).,,,CWE-126,        if (strlen(node->name) == 0) {,4a8f14565a48081e1025a536990c9431c5d22fac87a944b3687ad39746522e10,2.0.19,FF1022,https://cwe.mitre.org/data/definitions/126.html
./ggml/src/ggml.c,6956,13,1,1,buffer,strlen,Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).,,,CWE-126,        if (strlen(node->name) > 0) {,d3d40341dc10821726c24f6ca2760052c6698458b4f44f3c34ca63eba6dfa08b,2.0.19,FF1022,https://cwe.mitre.org/data/definitions/126.html
./ggml/src/ggml.c,6985,13,1,1,buffer,strlen,Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).,,,CWE-126,        if (strlen(node->name) > 0) {,d3d40341dc10821726c24f6ca2760052c6698458b4f44f3c34ca63eba6dfa08b,2.0.19,FF1022,https://cwe.mitre.org/data/definitions/126.html
./ggml/src/gguf.cpp,225,10,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",    bool read(T & dst) const {,91e68cc0dc0a0415ca727898d6befe5325c8cba0c94e5311cf3d95df24067414,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,230,10,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","    bool read(std::vector<T> & dst, const size_t n) const {",c2fc3523ba58dfc25bf6895a8c0ad59f6f283a419b1d69331dcb69154806e1bb,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,235,22,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",                if (!read(tmp)) {,778da1027035b7ae94d06404c93cfc37162e2891f6acd58474085aaca5817bbb,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,240,22,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",                if (!read(dst[i])) {,2379183c8385f5df3af9ccea9c30b4ca96ca2c37bbf4e4e34a332d72f530768f,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,248,10,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",    bool read(bool & dst) const {,335aa2229b07d1a6d477672b75cc8044b3232d5f29bc319462d7874f3a25f2e0,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,250,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",        if (!read(tmp)) {,778da1027035b7ae94d06404c93cfc37162e2891f6acd58474085aaca5817bbb,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,257,10,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",    bool read(enum ggml_type & dst) const {,28c3619d3ec0825fdc8630e6bb28bc8a39b534feb2106c39b2be0d825e12446b,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,259,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",        if (!read(tmp)) {,778da1027035b7ae94d06404c93cfc37162e2891f6acd58474085aaca5817bbb,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,266,10,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",    bool read(enum gguf_type & dst) const {,c1b3d018287bb27c439f7656cd3e4cb7a1090e9cc86e760a0329574c95ed3ea1,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,268,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",        if (!read(tmp)) {,778da1027035b7ae94d06404c93cfc37162e2891f6acd58474085aaca5817bbb,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,275,10,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",    bool read(std::string & dst) const {,451dbcd2479f88100a3724c01b262e7cef471af9a40dd9b704e30f81e030c5f7,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,277,14,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",        if (!read(size)) {,58f876c364ea12feeecfdb1fd1d9228fcccb810efcdfa26b792a6096a30e0734,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,284,10,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","    bool read(void * dst, const size_t size) const {",8e9134ddb84cc0306528853eb77285eebbfe66f5240f028c65eaba8c9d19913d,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,298,21,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            if (!gr.read(value, n)) {",861a343be1a786a8daba9af90f7ec1efb1306c896349742b310e7adb73161ffd,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,311,17,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",        if (!gr.read(value)) {,3e05dcfe7a46577f287b8cf15e9e14c74d62244c6dfabdf617f0effcdf92784a,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,328,23,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","        ok = ok && gr.read(magic, 4);",43e89774318bf46c49293ea2d454bfd03af7109484ce5358d1a68c823d792407,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,353,18,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",    if (ok && gr.read(ctx->version)) {,356f072d9d11ecd8ed9d30897dcc492d4a668a4e7f5cbfc36d4fb7034664c888,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,384,18,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",    if (ok && gr.read(n_tensors)) {,b68ac6fc4cf50d7ed513b0c40d51b28ebb238fcb8be95bb8334a091dea472fc1,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,395,18,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",    if (ok && gr.read(n_kv)) {,c601bf2204e36183434c35163bb800536ded51b7849b68430a99d92c7e12bb7b,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,421,31,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",                ok = ok && gr.read(key);,60a311e2c903785e2cbd56359a87a617f8ae4ef539f4149bca850912ec6c95c4,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,439,27,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",            ok = ok && gr.read(type);,e5e179cfd418fd4d2d78ee86318b8813a70e4ddb73ec4dce1370eacd354e12a1,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,442,31,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",                ok = ok && gr.read(type);,e5e179cfd418fd4d2d78ee86318b8813a70e4ddb73ec4dce1370eacd354e12a1,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,443,31,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",                ok = ok && gr.read(n);,e226d52170d6e3fa051fc0ff81129b1fdfcd5429a9bb73cff2b6917bf5ec2978,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,496,31,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",                ok = ok && gr.read(name);,27cc08541aa0a51d6bd96795994ac4e0730075a6af2aa7196bdb0bb6e5af73a9,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,527,27,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",            ok = ok && gr.read(n_dims);,2f088baf99941ed438fecda4962fd11a3b6706cdd73ce470a95ff2610e17c593,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,537,35,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",                    ok = ok && gr.read(info.t.ne[j]);,a990a7ad29b4d6ff6e24152385b9bac2d764e2178eb494b2d1302f50567110a6,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,567,27,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",            ok = ok && gr.read(info.t.type);,fa9d1d4e79d8f153e710b1ad5692823b09d994dad5aa0442bbec3a1eabdbd399,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,600,23,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20",        ok = ok && gr.read(info.offset);,c85f34f2faea4ee9f0636b5a97b4005dcab19e115e8aef6f9b767b80ba2d8647,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
./ggml/src/gguf.cpp,684,27,1,1,buffer,read,"Check buffer boundaries if used in a loop including recursive loops (CWE-120, CWE-20).",,,"CWE-120, CWE-20","            ok = ok && gr.read(data->data, ctx->size);",7c55caa037eb49701dc257c215e3874d7b15a76f2d1b01454bf6afdb3477a703,2.0.19,FF1029,https://cwe.mitre.org/data/definitions/120.html
